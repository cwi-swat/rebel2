// Static configuration of state machines
// Define the specs that can take place in the transition system
Roster (spec:id) = {<roster>}
Doctor (spec:id) = {<doctor>}

// Define all possible states for all machines
State (state:id) = {<state_uninitialized>,<state_finalized>,<state_roster_active>,<state_doctor_offcall>,<state_doctor_oncall>}
initialized (state:id) = {<state_roster_active>,<state_doctor_offcall>,<state_doctor_oncall>}
finalized (state:id) = {<state_finalized>}
uninitialized (state:id) = {<state_uninitialized>}
StateRosterActive (state:id) = {<state_roster_active>}

StateDoctorOnCall (state:id) = {<state_doctor_oncall>}
StateDoctorOffCall (state:id) = {<state_doctor_offcall>}


// Define which transitions are allowed (in the form of `from a state` -> ` via an event` -> `to a state`
allowedTransitions (from:id, to:id, event:id) = {<state_roster_active,state_roster_active,event_roster_gooffcall>,<state_roster_active,state_roster_active,event_roster_gooncall>,<state_doctor_offcall,state_doctor_oncall,event_doctor_gooncall>,<state_doctor_oncall,state_doctor_offcall,event_doctor_gooffcall>}
// Define each event as single relation so that the events can be used as variables in the constraints 
EventRosterGoOnCall (event:id) = {<event_roster_gooncall>}
EventDoctorGoOnCall (event:id) = {<event_doctor_gooncall>}
EventDoctor__frame (event:id) = {<event_doctor___frame>}
EventRoster__frame (event:id) = {<event_roster___frame>}
EventRosterGoOffCall (event:id) = {<event_roster_gooffcall>}
EventDoctorGoOffCall (event:id) = {<event_doctor_gooffcall>}



// Dynamic configuration of state machines
Config (config:id) >= {<c1>} <= {<c1>,<c2>,<c3>,<c4>,<c5>,<c6>,<c7>,<c8>,<c9>,<c10>,<c11>}
order (cur:id, nxt:id) <= {<c1,c2>,<c2,c3>,<c3,c4>,<c4,c5>,<c5,c6>,<c6,c7>,<c7,c8>,<c8,c9>,<c9,c10>,<c10,c11>}
first (config:id) = {<c1>}
last (config:id) <= {<c1>,<c2>,<c3>,<c4>,<c5>,<c6>,<c7>,<c8>,<c9>,<c10>,<c11>}
back (config:id) = {}
loop (cur:id, nxt:id) = {}

Instance (spec:id, instance:id) = {<roster,r>,<doctor,carol>,<doctor,bob>,<doctor,alice>}
instanceInState (config:id, instance:id, state:id) <= {<c1,r,state_roster_active>,<c1,alice,state_doctor_oncall>,<c1,alice,state_doctor_offcall>,<c1,carol,state_doctor_oncall>,<c1,carol,state_doctor_offcall>,<c1,bob,state_doctor_oncall>,<c1,bob,state_doctor_offcall>,<c2,r,state_roster_active>,<c2,alice,state_doctor_oncall>,<c2,alice,state_doctor_offcall>,<c2,carol,state_doctor_oncall>,<c2,carol,state_doctor_offcall>,<c2,bob,state_doctor_oncall>,<c2,bob,state_doctor_offcall>,<c3,r,state_roster_active>,<c3,alice,state_doctor_oncall>,<c3,alice,state_doctor_offcall>,<c3,carol,state_doctor_oncall>,<c3,carol,state_doctor_offcall>,<c3,bob,state_doctor_oncall>,<c3,bob,state_doctor_offcall>,<c4,r,state_roster_active>,<c4,alice,state_doctor_oncall>,<c4,alice,state_doctor_offcall>,<c4,carol,state_doctor_oncall>,<c4,carol,state_doctor_offcall>,<c4,bob,state_doctor_oncall>,<c4,bob,state_doctor_offcall>,<c5,r,state_roster_active>,<c5,alice,state_doctor_oncall>,<c5,alice,state_doctor_offcall>,<c5,carol,state_doctor_oncall>,<c5,carol,state_doctor_offcall>,<c5,bob,state_doctor_oncall>,<c5,bob,state_doctor_offcall>,<c6,r,state_roster_active>,<c6,alice,state_doctor_oncall>,<c6,alice,state_doctor_offcall>,<c6,carol,state_doctor_oncall>,<c6,carol,state_doctor_offcall>,<c6,bob,state_doctor_oncall>,<c6,bob,state_doctor_offcall>,<c7,r,state_roster_active>,<c7,alice,state_doctor_oncall>,<c7,alice,state_doctor_offcall>,<c7,carol,state_doctor_oncall>,<c7,carol,state_doctor_offcall>,<c7,bob,state_doctor_oncall>,<c7,bob,state_doctor_offcall>,<c8,r,state_roster_active>,<c8,alice,state_doctor_oncall>,<c8,alice,state_doctor_offcall>,<c8,carol,state_doctor_oncall>,<c8,carol,state_doctor_offcall>,<c8,bob,state_doctor_oncall>,<c8,bob,state_doctor_offcall>,<c9,r,state_roster_active>,<c9,alice,state_doctor_oncall>,<c9,alice,state_doctor_offcall>,<c9,carol,state_doctor_oncall>,<c9,carol,state_doctor_offcall>,<c9,bob,state_doctor_oncall>,<c9,bob,state_doctor_offcall>,<c10,r,state_roster_active>,<c10,alice,state_doctor_oncall>,<c10,alice,state_doctor_offcall>,<c10,carol,state_doctor_oncall>,<c10,carol,state_doctor_offcall>,<c10,bob,state_doctor_oncall>,<c10,bob,state_doctor_offcall>,<c11,r,state_roster_active>,<c11,alice,state_doctor_oncall>,<c11,alice,state_doctor_offcall>,<c11,carol,state_doctor_oncall>,<c11,carol,state_doctor_offcall>,<c11,bob,state_doctor_oncall>,<c11,bob,state_doctor_offcall>}
raisedEvent (cur:id, nxt:id, event:id, instance:id) <= {<c1,c2,event_roster_gooncall,r>,<c1,c2,event_roster_gooffcall,r>,<c2,c3,event_roster_gooncall,r>,<c2,c3,event_roster_gooffcall,r>,<c3,c4,event_roster_gooncall,r>,<c3,c4,event_roster_gooffcall,r>,<c4,c5,event_roster_gooncall,r>,<c4,c5,event_roster_gooffcall,r>,<c5,c6,event_roster_gooncall,r>,<c5,c6,event_roster_gooffcall,r>,<c6,c7,event_roster_gooncall,r>,<c6,c7,event_roster_gooffcall,r>,<c7,c8,event_roster_gooncall,r>,<c7,c8,event_roster_gooffcall,r>,<c8,c9,event_roster_gooncall,r>,<c8,c9,event_roster_gooffcall,r>,<c9,c10,event_roster_gooncall,r>,<c9,c10,event_roster_gooffcall,r>,<c10,c11,event_roster_gooncall,r>,<c10,c11,event_roster_gooffcall,r>}
changedInstance (cur:id, nxt:id, instance:id) <= {<c1,c2,r>,<c1,c2,alice>,<c1,c2,carol>,<c1,c2,bob>,<c2,c3,r>,<c2,c3,alice>,<c2,c3,carol>,<c2,c3,bob>,<c3,c4,r>,<c3,c4,alice>,<c3,c4,carol>,<c3,c4,bob>,<c4,c5,r>,<c4,c5,alice>,<c4,c5,carol>,<c4,c5,bob>,<c5,c6,r>,<c5,c6,alice>,<c5,c6,carol>,<c5,c6,bob>,<c6,c7,r>,<c6,c7,alice>,<c6,c7,carol>,<c6,c7,bob>,<c7,c8,r>,<c7,c8,alice>,<c7,c8,carol>,<c7,c8,bob>,<c8,c9,r>,<c8,c9,alice>,<c8,c9,carol>,<c8,c9,bob>,<c9,c10,r>,<c9,c10,alice>,<c9,c10,carol>,<c9,c10,bob>,<c10,c11,r>,<c10,c11,alice>,<c10,c11,carol>,<c10,c11,bob>}

RosterDoctors (config:id, instance:id, doctors:id) <= {<c1,r,alice>,<c1,r,carol>,<c1,r,bob>,<c2,r,alice>,<c2,r,carol>,<c2,r,bob>,<c3,r,alice>,<c3,r,carol>,<c3,r,bob>,<c4,r,alice>,<c4,r,carol>,<c4,r,bob>,<c5,r,alice>,<c5,r,carol>,<c5,r,bob>,<c6,r,alice>,<c6,r,carol>,<c6,r,bob>,<c7,r,alice>,<c7,r,carol>,<c7,r,bob>,<c8,r,alice>,<c8,r,carol>,<c8,r,bob>,<c9,r,alice>,<c9,r,carol>,<c9,r,bob>,<c10,r,alice>,<c10,r,carol>,<c10,r,bob>,<c11,r,alice>,<c11,r,carol>,<c11,r,bob>}


ParamEventRosterGoOnCallD (cur:id, nxt:id, d:id) <= {<c1,c2,alice>,<c1,c2,carol>,<c1,c2,bob>,<c2,c3,alice>,<c2,c3,carol>,<c2,c3,bob>,<c3,c4,alice>,<c3,c4,carol>,<c3,c4,bob>,<c4,c5,alice>,<c4,c5,carol>,<c4,c5,bob>,<c5,c6,alice>,<c5,c6,carol>,<c5,c6,bob>,<c6,c7,alice>,<c6,c7,carol>,<c6,c7,bob>,<c7,c8,alice>,<c7,c8,carol>,<c7,c8,bob>,<c8,c9,alice>,<c8,c9,carol>,<c8,c9,bob>,<c9,c10,alice>,<c9,c10,carol>,<c9,c10,bob>,<c10,c11,alice>,<c10,c11,carol>,<c10,c11,bob>}
ParamEventRosterGoOffCallD (cur:id, nxt:id, d:id) <= {<c1,c2,alice>,<c1,c2,carol>,<c1,c2,bob>,<c2,c3,alice>,<c2,c3,carol>,<c2,c3,bob>,<c3,c4,alice>,<c3,c4,carol>,<c3,c4,bob>,<c4,c5,alice>,<c4,c5,carol>,<c4,c5,bob>,<c5,c6,alice>,<c5,c6,carol>,<c5,c6,bob>,<c6,c7,alice>,<c6,c7,carol>,<c6,c7,bob>,<c7,c8,alice>,<c7,c8,carol>,<c7,c8,bob>,<c8,c9,alice>,<c8,c9,carol>,<c8,c9,bob>,<c9,c10,alice>,<c9,c10,carol>,<c9,c10,bob>,<c10,c11,alice>,<c10,c11,carol>,<c10,c11,bob>}
    

// Constraints for the configuration and ordering relations
order ⊆ Config[config as cur] ⨯ Config[config as nxt]
last = Config ∖ order[cur->config]  // There is only one last configuration
 

// Generic 'Type' constraints    
raisedEvent ⊆ (order) ⨯ allowedTransitions[event] ⨯ Instance[instance]
instanceInState ⊆ Instance[instance] ⨯ Config ⨯ State
changedInstance ⊆ (order) ⨯ Instance[instance]
    
// Machine specific `type` constraints
// For `Roster`
ParamEventRosterGoOffCallD ⊆ (order ∪ loop) ⨯ (Instance ⨝ Doctor)[instance->d]
RosterDoctors  ⊆ Config ⨯ (Instance ⨝ Roster)[instance] ⨯ (Instance ⨝ Doctor)[instance->doctors]
ParamEventRosterGoOnCallD ⊆ (order ∪ loop) ⨯ (Instance ⨝ Doctor)[instance->d]


// Specific per event: parameter multiplicity constraints
∀ step ∈ (order ∪ loop) ⨝ raisedEvent | (
  (some (step ⨝ EventRosterGoOffCall) ⇔ one (step ⨝ ParamEventRosterGoOffCallD)) ∧
  (some (step ⨝ EventRosterGoOnCall) ⇔ one (step ⨝ ParamEventRosterGoOnCallD))
)
// Generic: All configurations are reachable
∀ c ∈ Config ∖ first | c ⊆ (first[config as cur] ⨝ ^<cur,nxt>order)[nxt -> config]

// Generic: Every transition can only happen by exactly one event
∀ o ∈ order | one o ⨝ raisedEvent

// Specif: In every configuration all machines have a state IFF its a machine which is not empty
∀ c ∈ Config, inst ∈ Instance | one instanceInState ⨝ c ⨝ inst

// Specific per machine: In every configuration iff a machine is in an initialized state then it must have values
// for `Roster`
∀ c ∈ Config, inst ∈ (Instance ⨝ Roster)[instance] | (no (((c ⨯ inst) ⨝ instanceInState)[state] ∩ initialized) ⇒ no RosterDoctors ⨝ c ⨝ inst)

// Generic: Transitions are only allowed between if an event is specified between two states
∀ o ∈ (order) ⨝ raisedEvent | (o[cur as config] ⨝ instanceInState)[state->from] ⨯ (o[nxt as config] ⨝ instanceInState)[state->to] ⨯ o[event] ⊆ allowedTransitions

// Change set predicates
pred inChangeSet[step: (cur:id, nxt:id), instances: (instance:id)]
  = instances ⊆ (changedInstance ⨝ step)[instance]
 
pred notInChangeSet[step: (cur:id, nxt:id), instances: (instance:id)]
  = no instances ∩ (changedInstance ⨝ step)[instance]

pred changeSetCanContain[step: (cur:id, nxt:id), instances: (instance:id)]
  = (changedInstance ⨝ step)[instance] ⊆ instances 

// Generic predicates
pred forceState[curState: (state:id), nxtState: (state:id), raisedEvent: (event:id)]
  = nxtState = (curState[state as from] ⨝ (allowedTransitions ⨝ raisedEvent))[to->state]

pred inState[config: (config:id), instance: (instance:id), state: (state:id)]
  = ((instance ⨯ config) ⨝ instanceInState)[state] ⊆ state

// Event predicates for `Roster`
pred frameRoster[step: (cur:id, nxt:id), roster: (instance:id)] 
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ roster)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ roster)[state] | (
    nxtState = curState ∧
    (
      curState ⊆ uninitialized ∨ 
      (// Postconditions
       (roster ⨝ (RosterDoctors ⨝ nxt))[doctors] = (roster ⨝ (RosterDoctors ⨝ cur))[doctors])
    )
  )

pred eventRosterGoOnCall[step:(cur:id, nxt:id), roster: (instance:id), d: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ roster)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ roster)[state] |
    ( 
      // Preconditions 
      some ((roster ⨝ (RosterDoctors ⨝ cur))[doctors] ∩ d[instance->doctors]) ∧
      eventDoctorGoOnCall[step, d]  ∧ 
      // Postconditions
      (roster ⨝ (RosterDoctors ⨝ nxt))[doctors] = (roster ⨝ (RosterDoctors ⨝ cur))[doctors]  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventRosterGoOnCall] ∧
      // Make sure this instance is in the change set
      inChangeSet[step, roster]
    )

pred eventRosterGoOffCall[step:(cur:id, nxt:id), roster: (instance:id), d: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ roster)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ roster)[state] |
    ( 
      // Preconditions 
      some ((roster ⨝ (RosterDoctors ⨝ cur))[doctors] ∩ d[instance->doctors]) ∧
      eventDoctorGoOffCall[step, d] ∧
      (∃ other ∈ (roster ⨝ (RosterDoctors ⨝ cur))[doctors] | (other != d[instance as doctors] ∧ inState[cur, other[doctors as instance], StateDoctorOnCall]))  ∧ 
      // Postconditions
      (roster ⨝ (RosterDoctors ⨝ nxt))[doctors] = (roster ⨝ (RosterDoctors ⨝ cur))[doctors]  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventRosterGoOffCall] ∧
      // Make sure this instance is in the change set
      inChangeSet[step, roster]
    )

// Event predicates for `Doctor`
pred eventDoctorGoOnCall[step:(cur:id, nxt:id), doctor: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ doctor)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ doctor)[state] |
    ( 
       
       
      // Generic event conditions
      forceState[curState, nxtState, EventDoctorGoOnCall] ∧
      // Make sure this instance is in the change set
      inChangeSet[step, doctor]
    )

pred frameDoctor[step: (cur:id, nxt:id), doctor: (instance:id)] 
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ doctor)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ doctor)[state] | (
    nxtState = curState 
  )

pred eventDoctorGoOffCall[step:(cur:id, nxt:id), doctor: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ doctor)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ doctor)[state] |
    ( 
       
       
      // Generic event conditions
      forceState[curState, nxtState, EventDoctorGoOffCall] ∧
      // Make sure this instance is in the change set
      inChangeSet[step, doctor]
    )


// Transition function for `Roster`
pred possibleTransitionsRoster[step: (cur:id, nxt:id)] 
  = ∀ inst ∈ (Instance ⨝ Roster)[instance] |
    (some inst ∩ ((raisedEvent ⨝ step)[instance]) ⇔ (
      (eventRosterGoOnCall[step,inst,(step ⨝ ParamEventRosterGoOnCallD)[d->instance]] ∧
      (step ⨝ raisedEvent)[event] = EventRosterGoOnCall ∧
      let cur = step[cur->config], d = (ParamEventRosterGoOnCallD ⨝ step)[d -> instance] | changeSetCanContain[step, d ∪ inst])
      ∨
      (eventRosterGoOffCall[step,inst,(step ⨝ ParamEventRosterGoOffCallD)[d->instance]] ∧
      (step ⨝ raisedEvent)[event] = EventRosterGoOffCall ∧
      let cur = step[cur->config], d = (ParamEventRosterGoOffCallD ⨝ step)[d -> instance] | changeSetCanContain[step, d ∪ inst])
    ))
    ∧
    (notInChangeSet[step, inst] ⇒ frameRoster[step, inst])

// Transition function for `Doctor`
pred possibleTransitionsDoctor[step: (cur:id, nxt:id)] 
  = ∀ inst ∈ (Instance ⨝ Doctor)[instance] |
    
    (notInChangeSet[step, inst] ⇒ frameDoctor[step, inst])


// Transition function
∀ step ∈ order| possibleTransitionsRoster[step] ∧ possibleTransitionsDoctor[step]


// Fact `InitiallyThereIsADoctorOnCall`
let cur_1 = first | (∃ d ∈ (Instance ⨝ Doctor)[instance] | inState[cur_1, d, StateDoctorOnCall])
// Fact `AlwaysAnActiveRoster`
∀ cur_1 ∈ Config | let step_1 = cur_1[config as cur] ⨝ (order ∪ loop) | (∃ r ∈ (Instance ⨝ Roster)[instance] | inState[cur_1, r, StateRosterActive])
// Fact `AllDoctorsAreOnTheRoster`
∀ cur_1 ∈ Config | let step_1 = cur_1[config as cur] ⨝ (order ∪ loop) | (∀ d ∈ (Instance ⨝ Doctor)[instance] | (∃ r ∈ (Instance ⨝ Roster)[instance] | some ((r ⨝ (RosterDoctors ⨝ cur_1))[doctors] ∩ d[instance->doctors])))

// Assert `NoDoctorOnCall`
∃ cur_1 ∈ Config | let step_1 = cur_1[config as cur] ⨝ (order ∪ loop) | (∀ d ∈ (Instance ⨝ Doctor)[instance] | inState[cur_1, d, StateDoctorOffCall])
// Minimize the number of steps by minimizing the number of Configurations
objectives: minimize Config[count()]