// Static configuration of state machines
// Define the specs that can take place in the transition system
FlashLight (spec:id) = {<flashlight>}
Traveller (spec:id) = {<traveller>}

// Define all possible states for all machines
State (state:id) = {<state_uninitialized>,<state_finalized>,<state_flashlight_near>,<state_flashlight_far>,<state_traveller_near>,<state_traveller_far>}
initialized (state:id) = {<state_flashlight_near>,<state_flashlight_far>,<state_traveller_near>,<state_traveller_far>}
finalized (state:id) = {<state_finalized>}
uninitialized (state:id) = {<state_uninitialized>}
StateFlashLightNear (state:id) = {<state_flashlight_near>}StateFlashLightFar (state:id) = {<state_flashlight_far>}
StateTravellerNear (state:id) = {<state_traveller_near>}StateTravellerFar (state:id) = {<state_traveller_far>}

// Define which transitions are allowed (in the form of `from a state` -> ` via an event` -> `to a state`
allowedTransitions (from:id, to:id, event:id) = {<state_flashlight_far,state_flashlight_near,event_flashlight_crossfartonear>,<state_uninitialized,state_flashlight_near,event_flashlight_initialize>,<state_flashlight_near,state_flashlight_far,event_flashlight_crossneartofar>,<state_uninitialized,state_traveller_near,event_traveller_initialize>,<state_traveller_near,state_traveller_far,event_traveller_cross>,<state_traveller_far,state_traveller_near,event_traveller_cross>}
// Define each event as single relation so that the events can be used as variables in the constraints 
EventFlashLight__frame (event:id) = {<event_flashlight___frame>}
EventTravellerInitialize (event:id) = {<event_traveller_initialize>}
EventTravellerCross (event:id) = {<event_traveller_cross>}
EventTraveller__frame (event:id) = {<event_traveller___frame>}
EventFlashLightInitialize (event:id) = {<event_flashlight_initialize>}
EventFlashLightCrossNearToFar (event:id) = {<event_flashlight_crossneartofar>}
EventFlashLightCrossFarToNear (event:id) = {<event_flashlight_crossfartonear>}


// Dynamic configuration of state machines
Config (config:id) >= {<c1>} <= {<c1>,<c2>,<c3>,<c4>,<c5>,<c6>,<c7>}
order (cur:id, nxt:id) <= {<c1,c2>,<c2,c3>,<c3,c4>,<c4,c5>,<c5,c6>,<c6,c7>}
InitialConfig (config:id) = {<c1>}

Instance (spec:id, instance:id) = {<flashlight,fl1>,<traveller,t2>,<traveller,t3>,<traveller,t1>,<traveller,t4>}
instanceInState (config:id, instance:id, state:id) >= {<c1,fl1,state_flashlight_near>,<c1,t2,state_traveller_near>,<c1,t3,state_traveller_near>,<c1,t1,state_traveller_near>,<c1,t4,state_traveller_near>}<= {<c1,fl1,state_flashlight_far>,<c1,fl1,state_uninitialized>,<c1,fl1,state_flashlight_near>,<c1,fl1,state_finalized>,<c1,t4,state_traveller_far>,<c1,t4,state_uninitialized>,<c1,t4,state_traveller_near>,<c1,t4,state_finalized>,<c1,t1,state_traveller_far>,<c1,t1,state_uninitialized>,<c1,t1,state_traveller_near>,<c1,t1,state_finalized>,<c1,t2,state_traveller_far>,<c1,t2,state_uninitialized>,<c1,t2,state_traveller_near>,<c1,t2,state_finalized>,<c1,t3,state_traveller_far>,<c1,t3,state_uninitialized>,<c1,t3,state_traveller_near>,<c1,t3,state_finalized>,<c2,fl1,state_flashlight_far>,<c2,fl1,state_uninitialized>,<c2,fl1,state_flashlight_near>,<c2,fl1,state_finalized>,<c2,t4,state_traveller_far>,<c2,t4,state_uninitialized>,<c2,t4,state_traveller_near>,<c2,t4,state_finalized>,<c2,t1,state_traveller_far>,<c2,t1,state_uninitialized>,<c2,t1,state_traveller_near>,<c2,t1,state_finalized>,<c2,t2,state_traveller_far>,<c2,t2,state_uninitialized>,<c2,t2,state_traveller_near>,<c2,t2,state_finalized>,<c2,t3,state_traveller_far>,<c2,t3,state_uninitialized>,<c2,t3,state_traveller_near>,<c2,t3,state_finalized>,<c3,fl1,state_flashlight_far>,<c3,fl1,state_uninitialized>,<c3,fl1,state_flashlight_near>,<c3,fl1,state_finalized>,<c3,t4,state_traveller_far>,<c3,t4,state_uninitialized>,<c3,t4,state_traveller_near>,<c3,t4,state_finalized>,<c3,t1,state_traveller_far>,<c3,t1,state_uninitialized>,<c3,t1,state_traveller_near>,<c3,t1,state_finalized>,<c3,t2,state_traveller_far>,<c3,t2,state_uninitialized>,<c3,t2,state_traveller_near>,<c3,t2,state_finalized>,<c3,t3,state_traveller_far>,<c3,t3,state_uninitialized>,<c3,t3,state_traveller_near>,<c3,t3,state_finalized>,<c4,fl1,state_flashlight_far>,<c4,fl1,state_uninitialized>,<c4,fl1,state_flashlight_near>,<c4,fl1,state_finalized>,<c4,t4,state_traveller_far>,<c4,t4,state_uninitialized>,<c4,t4,state_traveller_near>,<c4,t4,state_finalized>,<c4,t1,state_traveller_far>,<c4,t1,state_uninitialized>,<c4,t1,state_traveller_near>,<c4,t1,state_finalized>,<c4,t2,state_traveller_far>,<c4,t2,state_uninitialized>,<c4,t2,state_traveller_near>,<c4,t2,state_finalized>,<c4,t3,state_traveller_far>,<c4,t3,state_uninitialized>,<c4,t3,state_traveller_near>,<c4,t3,state_finalized>,<c5,fl1,state_flashlight_far>,<c5,fl1,state_uninitialized>,<c5,fl1,state_flashlight_near>,<c5,fl1,state_finalized>,<c5,t4,state_traveller_far>,<c5,t4,state_uninitialized>,<c5,t4,state_traveller_near>,<c5,t4,state_finalized>,<c5,t1,state_traveller_far>,<c5,t1,state_uninitialized>,<c5,t1,state_traveller_near>,<c5,t1,state_finalized>,<c5,t2,state_traveller_far>,<c5,t2,state_uninitialized>,<c5,t2,state_traveller_near>,<c5,t2,state_finalized>,<c5,t3,state_traveller_far>,<c5,t3,state_uninitialized>,<c5,t3,state_traveller_near>,<c5,t3,state_finalized>,<c6,fl1,state_flashlight_far>,<c6,fl1,state_uninitialized>,<c6,fl1,state_flashlight_near>,<c6,fl1,state_finalized>,<c6,t4,state_traveller_far>,<c6,t4,state_uninitialized>,<c6,t4,state_traveller_near>,<c6,t4,state_finalized>,<c6,t1,state_traveller_far>,<c6,t1,state_uninitialized>,<c6,t1,state_traveller_near>,<c6,t1,state_finalized>,<c6,t2,state_traveller_far>,<c6,t2,state_uninitialized>,<c6,t2,state_traveller_near>,<c6,t2,state_finalized>,<c6,t3,state_traveller_far>,<c6,t3,state_uninitialized>,<c6,t3,state_traveller_near>,<c6,t3,state_finalized>,<c7,fl1,state_flashlight_far>,<c7,fl1,state_uninitialized>,<c7,fl1,state_flashlight_near>,<c7,fl1,state_finalized>,<c7,t4,state_traveller_far>,<c7,t4,state_uninitialized>,<c7,t4,state_traveller_near>,<c7,t4,state_finalized>,<c7,t1,state_traveller_far>,<c7,t1,state_uninitialized>,<c7,t1,state_traveller_near>,<c7,t1,state_finalized>,<c7,t2,state_traveller_far>,<c7,t2,state_uninitialized>,<c7,t2,state_traveller_near>,<c7,t2,state_finalized>,<c7,t3,state_traveller_far>,<c7,t3,state_uninitialized>,<c7,t3,state_traveller_near>,<c7,t3,state_finalized>}
raisedEvent (cur:id, nxt:id, event:id, instance:id) <= {<c1,c2,event_flashlight_initialize,fl1>,<c1,c2,event_flashlight_crossneartofar,fl1>,<c1,c2,event_flashlight_crossfartonear,fl1>,<c2,c3,event_flashlight_initialize,fl1>,<c2,c3,event_flashlight_crossneartofar,fl1>,<c2,c3,event_flashlight_crossfartonear,fl1>,<c3,c4,event_flashlight_initialize,fl1>,<c3,c4,event_flashlight_crossneartofar,fl1>,<c3,c4,event_flashlight_crossfartonear,fl1>,<c4,c5,event_flashlight_initialize,fl1>,<c4,c5,event_flashlight_crossneartofar,fl1>,<c4,c5,event_flashlight_crossfartonear,fl1>,<c5,c6,event_flashlight_initialize,fl1>,<c5,c6,event_flashlight_crossneartofar,fl1>,<c5,c6,event_flashlight_crossfartonear,fl1>,<c6,c7,event_flashlight_initialize,fl1>,<c6,c7,event_flashlight_crossneartofar,fl1>,<c6,c7,event_flashlight_crossfartonear,fl1>,<c1,c2,event_traveller_initialize,t4>,<c2,c3,event_traveller_initialize,t4>,<c3,c4,event_traveller_initialize,t4>,<c4,c5,event_traveller_initialize,t4>,<c5,c6,event_traveller_initialize,t4>,<c6,c7,event_traveller_initialize,t4>,<c1,c2,event_traveller_initialize,t1>,<c2,c3,event_traveller_initialize,t1>,<c3,c4,event_traveller_initialize,t1>,<c4,c5,event_traveller_initialize,t1>,<c5,c6,event_traveller_initialize,t1>,<c6,c7,event_traveller_initialize,t1>,<c1,c2,event_traveller_initialize,t2>,<c2,c3,event_traveller_initialize,t2>,<c3,c4,event_traveller_initialize,t2>,<c4,c5,event_traveller_initialize,t2>,<c5,c6,event_traveller_initialize,t2>,<c6,c7,event_traveller_initialize,t2>,<c1,c2,event_traveller_initialize,t3>,<c2,c3,event_traveller_initialize,t3>,<c3,c4,event_traveller_initialize,t3>,<c4,c5,event_traveller_initialize,t3>,<c5,c6,event_traveller_initialize,t3>,<c6,c7,event_traveller_initialize,t3>}
changedInstance (cur:id, nxt:id, instance:id) <= {<c1,c2,t4>,<c1,c2,fl1>,<c1,c2,t1>,<c1,c2,t2>,<c1,c2,t3>,<c2,c3,t4>,<c2,c3,fl1>,<c2,c3,t1>,<c2,c3,t2>,<c2,c3,t3>,<c3,c4,t4>,<c3,c4,fl1>,<c3,c4,t1>,<c3,c4,t2>,<c3,c4,t3>,<c4,c5,t4>,<c4,c5,fl1>,<c4,c5,t1>,<c4,c5,t2>,<c4,c5,t3>,<c5,c6,t4>,<c5,c6,fl1>,<c5,c6,t1>,<c5,c6,t2>,<c5,c6,t3>,<c6,c7,t4>,<c6,c7,fl1>,<c6,c7,t1>,<c6,c7,t2>,<c6,c7,t3>}

FlashLightTotalTimeSpend (config:id, instance:id, totalTimeSpend:int) >= {<c1,fl1,0>} <= {<c2,fl1,?>,<c3,fl1,?>,<c4,fl1,?>,<c5,fl1,?>,<c6,fl1,?>,<c7,fl1,?>}
TravellerTimeToCross (config:id, instance:id, timeToCross:int) >= {<c1,t2,2>,<c1,t3,5>,<c1,t4,10>,<c1,t1,1>} <= {<c2,t4,?>,<c3,t4,?>,<c4,t4,?>,<c5,t4,?>,<c6,t4,?>,<c7,t4,?>,<c2,t1,?>,<c3,t1,?>,<c4,t1,?>,<c5,t1,?>,<c6,t1,?>,<c7,t1,?>,<c2,t2,?>,<c3,t2,?>,<c4,t2,?>,<c5,t2,?>,<c6,t2,?>,<c7,t2,?>,<c2,t3,?>,<c3,t3,?>,<c4,t3,?>,<c5,t3,?>,<c6,t3,?>,<c7,t3,?>}

ParamEventFlashLightCrossFarToNearCarrier (cur:id, nxt:id, carrier:id) <= {<c1,c2,t4>,<c1,c2,t1>,<c1,c2,t2>,<c1,c2,t3>,<c2,c3,t4>,<c2,c3,t1>,<c2,c3,t2>,<c2,c3,t3>,<c3,c4,t4>,<c3,c4,t1>,<c3,c4,t2>,<c3,c4,t3>,<c4,c5,t4>,<c4,c5,t1>,<c4,c5,t2>,<c4,c5,t3>,<c5,c6,t4>,<c5,c6,t1>,<c5,c6,t2>,<c5,c6,t3>,<c6,c7,t4>,<c6,c7,t1>,<c6,c7,t2>,<c6,c7,t3>}
ParamEventFlashLightCrossFarToNearCrossingTimeCarrier (cur:id, nxt:id, crossingTimeCarrier:int) <= {<c1,c2,?>,<c2,c3,?>,<c3,c4,?>,<c4,c5,?>,<c5,c6,?>,<c6,c7,?>}
ParamEventFlashLightCrossNearToFarCarrier (cur:id, nxt:id, carrier:id) <= {<c1,c2,t4>,<c1,c2,t1>,<c1,c2,t2>,<c1,c2,t3>,<c2,c3,t4>,<c2,c3,t1>,<c2,c3,t2>,<c2,c3,t3>,<c3,c4,t4>,<c3,c4,t1>,<c3,c4,t2>,<c3,c4,t3>,<c4,c5,t4>,<c4,c5,t1>,<c4,c5,t2>,<c4,c5,t3>,<c5,c6,t4>,<c5,c6,t1>,<c5,c6,t2>,<c5,c6,t3>,<c6,c7,t4>,<c6,c7,t1>,<c6,c7,t2>,<c6,c7,t3>}
ParamEventFlashLightCrossNearToFarPassenger (cur:id, nxt:id, passenger:id) <= {<c1,c2,t4>,<c1,c2,t1>,<c1,c2,t2>,<c1,c2,t3>,<c2,c3,t4>,<c2,c3,t1>,<c2,c3,t2>,<c2,c3,t3>,<c3,c4,t4>,<c3,c4,t1>,<c3,c4,t2>,<c3,c4,t3>,<c4,c5,t4>,<c4,c5,t1>,<c4,c5,t2>,<c4,c5,t3>,<c5,c6,t4>,<c5,c6,t1>,<c5,c6,t2>,<c5,c6,t3>,<c6,c7,t4>,<c6,c7,t1>,<c6,c7,t2>,<c6,c7,t3>}
ParamEventFlashLightCrossNearToFarCrossingTimeCarrier (cur:id, nxt:id, crossingTimeCarrier:int) <= {<c1,c2,?>,<c2,c3,?>,<c3,c4,?>,<c4,c5,?>,<c5,c6,?>,<c6,c7,?>}
ParamEventFlashLightCrossNearToFarCrossingTimePassenger (cur:id, nxt:id, crossingTimePassenger:int) <= {<c1,c2,?>,<c2,c3,?>,<c3,c4,?>,<c4,c5,?>,<c5,c6,?>,<c6,c7,?>}
ParamEventTravellerCrossCrossingTime (cur:id, nxt:id, crossingTime:int) <= {<c1,c2,?>,<c2,c3,?>,<c3,c4,?>,<c4,c5,?>,<c5,c6,?>,<c6,c7,?>}
ParamEventTravellerInitializeTimeToCross (cur:id, nxt:id, timeToCross:int) <= {<c1,c2,?>,<c2,c3,?>,<c3,c4,?>,<c4,c5,?>,<c5,c6,?>,<c6,c7,?>}

// Generic 'Type' constraints
order ⊆ Config[config as cur] ⨯ Config[config as nxt]
raisedEvent ⊆ order ⨯ allowedTransitions[event] ⨯ Instance[instance]
instanceInState ⊆ Instance[instance] ⨯ Config ⨯ State
changedInstance ⊆ order ⨯ Instance[instance]
    
// Machine specific `type` constraints
FlashLightTotalTimeSpend[config,instance]  ⊆ Config ⨯ (Instance ⨝ FlashLight)[instance]
TravellerTimeToCross[config,instance]  ⊆ Config ⨯ (Instance ⨝ Traveller)[instance]

ParamEventFlashLightCrossNearToFarCarrier ⊆ order ⨯ (Instance ⨝ Traveller)[instance->carrier]
ParamEventFlashLightCrossNearToFarPassenger ⊆ order ⨯ (Instance ⨝ Traveller)[instance->passenger]
ParamEventFlashLightCrossNearToFarCrossingTimeCarrier[cur,nxt] ⊆ order
ParamEventFlashLightCrossNearToFarCrossingTimePassenger[cur,nxt] ⊆ order
ParamEventFlashLightCrossFarToNearCarrier ⊆ order ⨯ (Instance ⨝ Traveller)[instance->carrier]
ParamEventFlashLightCrossFarToNearCrossingTimeCarrier[cur,nxt] ⊆ order
ParamEventTravellerInitializeTimeToCross[cur,nxt] ⊆ order
ParamEventTravellerCrossCrossingTime[cur,nxt] ⊆ order

// Specific per event
∀ step ∈ order ⨝ raisedEvent | (
  (some (step ⨝ EventFlashLightCrossNearToFar) ⇔ one (step ⨝ ParamEventFlashLightCrossNearToFarCarrier)) ∧
  (some (step ⨝ EventFlashLightCrossNearToFar) ⇔ one (step ⨝ ParamEventFlashLightCrossNearToFarPassenger)) ∧
  (some (step ⨝ EventFlashLightCrossNearToFar) ⇔ one (step ⨝ ParamEventFlashLightCrossNearToFarCrossingTimeCarrier)) ∧
  (some (step ⨝ EventFlashLightCrossNearToFar) ⇔ one (step ⨝ ParamEventFlashLightCrossNearToFarCrossingTimePassenger)) ∧
  (some (step ⨝ EventFlashLightCrossFarToNear) ⇔ one (step ⨝ ParamEventFlashLightCrossFarToNearCarrier)) ∧
  (some (step ⨝ EventFlashLightCrossFarToNear) ⇔ one (step ⨝ ParamEventFlashLightCrossFarToNearCrossingTimeCarrier)) ∧
  (some (step ⨝ EventTravellerInitialize) ⇔ one (step ⨝ ParamEventTravellerInitializeTimeToCross)) ∧
  (some (step ⨝ EventTravellerCross) ⇔ one (step ⨝ ParamEventTravellerCrossCrossingTime))
)

// Generic: All configurations are reachable
∀ c ∈ Config ∖ InitialConfig | c ⊆ (InitialConfig[config as cur] ⨝ ^<cur,nxt>order)[nxt -> config]

// Generic: Every transition can only happen by exactly one event
∀ o ∈ order | one o ⨝ raisedEvent

// Generic: In every configuration all machines have a state
∀ c ∈ Config, inst ∈ Instance | one instanceInState ⨝ c ⨝ inst

// Specific per machine: In every configuration iff a machine is in an initialized state then it must have values
∀ c ∈ Config, inst ∈ (Instance ⨝ FlashLight)[instance] | (((c ⨯ inst) ⨝ instanceInState)[state] ⊆ initialized ⇔ one FlashLightTotalTimeSpend ⨝ c ⨝ inst)
∀ c ∈ Config, inst ∈ (Instance ⨝ Traveller)[instance] | (((c ⨯ inst) ⨝ instanceInState)[state] ⊆ initialized ⇔ one TravellerTimeToCross ⨝ c ⨝ inst)


// Generic: Transitions are only allowed between if an event is specified between two states
∀ o ∈ order ⨝ raisedEvent | (o[cur as config] ⨝ instanceInState)[state->from] ⨯ (o[nxt as config] ⨝ instanceInState)[state->to] ⨯ o[event] ⊆ allowedTransitions

// Generic predicates
pred forceState[curState: (state:id), nxtState: (state:id), raisedEvent: (event:id)]
  = nxtState = (curState[state as from] ⨝ (allowedTransitions ⨝ raisedEvent))[to->state]

pred inState[config: (config:id), instance: (instance:id), state: (state:id)]
  = ((instance ⨯ config) ⨝ instanceInState)[state] ⊆ state

pred eventFlashLightCrossFarToNear[step:(cur:id, nxt:id), flashlight: (instance:id), carrier: (carrier:id), crossingTimeCarrier: (crossingTimeCarrier:int)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ flashlight)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ flashlight)[state],
        curTotalTimeSpend = (cur ⨝ FlashLightTotalTimeSpend ⨝ flashlight)[totalTimeSpend->curTotalTimeSpend],
        nxtTotalTimeSpend = (nxt ⨝ FlashLightTotalTimeSpend ⨝ flashlight)[totalTimeSpend->nxtTotalTimeSpend] |
    ( 
      // Preconditions 
      inState[cur, carrier[carrier->instance], StateTravellerFar] ∧
      eventTravellerCross[step, carrier[carrier as instance], crossingTimeCarrier[crossingTimeCarrier as crossingTime]]  ∧ 
      // Postconditions
      (some (crossingTimeCarrier ⨯ curTotalTimeSpend ⨯ nxtTotalTimeSpend) where (nxtTotalTimeSpend = curTotalTimeSpend + crossingTimeCarrier))  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventFlashLightCrossFarToNear] ∧
      // Make sure this instance is in the change set
      flashlight ⊆ (changedInstance ⨝ step)[instance]
    )

pred frameFlashLight[step: (cur:id, nxt:id), flashlight: (instance:id)] 
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ flashlight)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ flashlight)[state],
        curTotalTimeSpend = (cur ⨝ FlashLightTotalTimeSpend ⨝ flashlight)[totalTimeSpend->curTotalTimeSpend],
        nxtTotalTimeSpend = (nxt ⨝ FlashLightTotalTimeSpend ⨝ flashlight)[totalTimeSpend->nxtTotalTimeSpend] | (
    nxtState = curState ∧
    (
      curState ⊆ uninitialized ∨ 
      (// Postconditions
       (some (curTotalTimeSpend ⨯ nxtTotalTimeSpend) where (nxtTotalTimeSpend = curTotalTimeSpend)))
    )
  )

pred eventFlashLightCrossNearToFar[step:(cur:id, nxt:id), flashlight: (instance:id), carrier: (carrier:id), passenger: (passenger:id), crossingTimeCarrier: (crossingTimeCarrier:int), crossingTimePassenger: (crossingTimePassenger:int)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ flashlight)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ flashlight)[state],
        curTotalTimeSpend = (cur ⨝ FlashLightTotalTimeSpend ⨝ flashlight)[totalTimeSpend->curTotalTimeSpend],
        nxtTotalTimeSpend = (nxt ⨝ FlashLightTotalTimeSpend ⨝ flashlight)[totalTimeSpend->nxtTotalTimeSpend] |
    ( 
      // Preconditions 
      inState[cur, carrier[carrier->instance], StateTravellerNear] ∧
      inState[cur, passenger[passenger->instance], StateTravellerNear] ∧
      eventTravellerCross[step, carrier[carrier as instance], crossingTimeCarrier[crossingTimeCarrier as crossingTime]] ∧
      eventTravellerCross[step, passenger[passenger as instance], crossingTimePassenger[crossingTimePassenger as crossingTime]]  ∧ 
      // Postconditions
      (((((some (crossingTimeCarrier ⨯ crossingTimePassenger) where (crossingTimeCarrier > crossingTimePassenger))) ⇒ (some (crossingTimeCarrier ⨯ curTotalTimeSpend ⨯ nxtTotalTimeSpend) where (nxtTotalTimeSpend = curTotalTimeSpend + crossingTimeCarrier)))) ∧ ((not ((((some (crossingTimeCarrier ⨯ crossingTimePassenger) where (crossingTimeCarrier > crossingTimePassenger))))) ⇒ (some (crossingTimePassenger ⨯ curTotalTimeSpend ⨯ nxtTotalTimeSpend) where (nxtTotalTimeSpend = curTotalTimeSpend + crossingTimePassenger)))))  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventFlashLightCrossNearToFar] ∧
      // Make sure this instance is in the change set
      flashlight ⊆ (changedInstance ⨝ step)[instance]
    )

pred eventFlashLightInitialize[step:(cur:id, nxt:id), flashlight: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ flashlight)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ flashlight)[state],
        curTotalTimeSpend = (cur ⨝ FlashLightTotalTimeSpend ⨝ flashlight)[totalTimeSpend->curTotalTimeSpend],
        nxtTotalTimeSpend = (nxt ⨝ FlashLightTotalTimeSpend ⨝ flashlight)[totalTimeSpend->nxtTotalTimeSpend] |
    ( 
       
      // Postconditions
      (some (nxtTotalTimeSpend) where (nxtTotalTimeSpend = 0))  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventFlashLightInitialize] ∧
      // Make sure this instance is in the change set
      flashlight ⊆ (changedInstance ⨝ step)[instance]
    )


pred possibleTransitionsFlashLight[step: (cur:id, nxt:id)] 
  = ∀ inst ∈ (Instance ⨝ FlashLight)[instance] |
    (some inst ∩ ((raisedEvent ⨝ step)[instance]) ⇔ (
      (eventFlashLightCrossFarToNear[step,inst,(step ⨝ ParamEventFlashLightCrossFarToNearCarrier)[carrier],(step ⨝ ParamEventFlashLightCrossFarToNearCrossingTimeCarrier)[crossingTimeCarrier]] ∧
      (step ⨝ raisedEvent)[event] = EventFlashLightCrossFarToNear ∧
      let cur = step[cur->config], carrier = (ParamEventFlashLightCrossFarToNearCarrier ⨝ step)[carrier -> instance] | (changedInstance ⨝ step)[instance] ⊆ inst ∪ carrier)
      ∨
      (eventFlashLightCrossNearToFar[step,inst,(step ⨝ ParamEventFlashLightCrossNearToFarCarrier)[carrier],(step ⨝ ParamEventFlashLightCrossNearToFarPassenger)[passenger],(step ⨝ ParamEventFlashLightCrossNearToFarCrossingTimeCarrier)[crossingTimeCarrier],(step ⨝ ParamEventFlashLightCrossNearToFarCrossingTimePassenger)[crossingTimePassenger]] ∧
      (step ⨝ raisedEvent)[event] = EventFlashLightCrossNearToFar ∧
      let cur = step[cur->config], carrier = (ParamEventFlashLightCrossNearToFarCarrier ⨝ step)[carrier -> instance], passenger = (ParamEventFlashLightCrossNearToFarPassenger ⨝ step)[passenger -> instance] | (changedInstance ⨝ step)[instance] ⊆ inst ∪ carrier ∪ passenger)
      ∨
      (eventFlashLightInitialize[step,inst] ∧
      (step ⨝ raisedEvent)[event] = EventFlashLightInitialize ∧
      (changedInstance ⨝ step)[instance] ⊆ inst)
    ))
    ∧
    (no inst ∩ (changedInstance ⨝ step)[instance] ⇒ frameFlashLight[step, inst])

pred frameTraveller[step: (cur:id, nxt:id), traveller: (instance:id)] 
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ traveller)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ traveller)[state],
        curTimeToCross = (cur ⨝ TravellerTimeToCross ⨝ traveller)[timeToCross->curTimeToCross],
        nxtTimeToCross = (nxt ⨝ TravellerTimeToCross ⨝ traveller)[timeToCross->nxtTimeToCross] | (
    nxtState = curState ∧
    (
      curState ⊆ uninitialized ∨ 
      (// Postconditions
       (some (nxtTimeToCross ⨯ curTimeToCross) where (nxtTimeToCross = curTimeToCross)))
    )
  )

pred eventTravellerCross[step:(cur:id, nxt:id), traveller: (instance:id), crossingTime: (crossingTime:int)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ traveller)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ traveller)[state],
        curTimeToCross = (cur ⨝ TravellerTimeToCross ⨝ traveller)[timeToCross->curTimeToCross],
        nxtTimeToCross = (nxt ⨝ TravellerTimeToCross ⨝ traveller)[timeToCross->nxtTimeToCross] |
    ( 
      // Preconditions 
      (some (crossingTime ⨯ curTimeToCross) where (crossingTime = curTimeToCross))  ∧ 
      // Postconditions
      (some (nxtTimeToCross ⨯ curTimeToCross) where (nxtTimeToCross = curTimeToCross))  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventTravellerCross] ∧
      // Make sure this instance is in the change set
      traveller ⊆ (changedInstance ⨝ step)[instance]
    )

pred eventTravellerInitialize[step:(cur:id, nxt:id), traveller: (instance:id), timeToCross: (timeToCross:int)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ traveller)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ traveller)[state],
        curTimeToCross = (cur ⨝ TravellerTimeToCross ⨝ traveller)[timeToCross->curTimeToCross],
        nxtTimeToCross = (nxt ⨝ TravellerTimeToCross ⨝ traveller)[timeToCross->nxtTimeToCross] |
    ( 
      // Preconditions 
      (some (timeToCross) where (timeToCross > 0))  ∧ 
      // Postconditions
      (some (nxtTimeToCross ⨯ timeToCross) where (nxtTimeToCross = timeToCross))  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventTravellerInitialize] ∧
      // Make sure this instance is in the change set
      traveller ⊆ (changedInstance ⨝ step)[instance]
    )


pred possibleTransitionsTraveller[step: (cur:id, nxt:id)] 
  = ∀ inst ∈ (Instance ⨝ Traveller)[instance] |
    (some inst ∩ ((raisedEvent ⨝ step)[instance]) ⇔ (
      (eventTravellerInitialize[step,inst,(step ⨝ ParamEventTravellerInitializeTimeToCross)[timeToCross]] ∧
      (step ⨝ raisedEvent)[event] = EventTravellerInitialize ∧
      (changedInstance ⨝ step)[instance] ⊆ inst)
    ))
    ∧
    (no inst ∩ (changedInstance ⨝ step)[instance] ⇒ frameTraveller[step, inst])


// Transition function
∀ step ∈ order | possibleTransitionsFlashLight[step] ∧ possibleTransitionsTraveller[step]

// Asserts: this is where the checks get added
exists c: Config | ((forall t ∈ (Instance ⨝ Traveller)[instance] | (instanceInState ⨝ t ⨝ c)[state] ⊆ StateTravellerFar) && (some (FlashLightTotalTimeSpend |x| c) where totalTimeSpend = 17))

// Minimize the number of steps by minimizing the number of Configurations
objectives: minimize Config[count()]
