// Static configuration of state machines
// Define the specs that can take place in the transition system
Adventurer (spec:id) = {<adventurer>}
FlashLight (spec:id) = {<flashlight>}

// Define all possible states for all machines
State (state:id) = {<state_uninitialized>,<state_finalized>,<state_adventurer_near>,<state_adventurer_far>,<state_flashlight_near>,<state_flashlight_far>}
initialized (state:id) = {<state_adventurer_near>,<state_adventurer_far>,<state_flashlight_near>,<state_flashlight_far>}
finalized (state:id) = {<state_finalized>}
uninitialized (state:id) = {<state_uninitialized>}
StateAdventurerNear (state:id) = {<state_adventurer_near>}StateAdventurerFar (state:id) = {<state_adventurer_far>}
StateFlashLightNear (state:id) = {<state_flashlight_near>}StateFlashLightFar (state:id) = {<state_flashlight_far>}

// Define which transitions are allowed (in the form of `from a state` -> ` via an event` -> `to a state`
allowedTransitions (from:id, to:id, event:id) = {<state_adventurer_far,state_adventurer_near,event_adventurer_cross>,<state_adventurer_near,state_adventurer_far,event_adventurer_cross>,<state_flashlight_far,state_flashlight_near,event_flashlight_crossfartonear>,<state_flashlight_near,state_flashlight_far,event_flashlight_crossneartofar>}
// Define each event as single relation so that the events can be used as variables in the constraints 
EventAdventurerCross (event:id) = {<event_adventurer_cross>}
EventFlashLight__frame (event:id) = {<event_flashlight___frame>}
EventAdventurer__frame (event:id) = {<event_adventurer___frame>}
EventFlashLightCrossNearToFar (event:id) = {<event_flashlight_crossneartofar>}
EventFlashLightCrossFarToNear (event:id) = {<event_flashlight_crossfartonear>}


// Dynamic configuration of state machines
Config (config:id) >= {<c1>} <= {<c1>,<c2>,<c3>,<c4>,<c5>,<c6>,<c7>}
order (cur:id, nxt:id) <= {<c1,c2>,<c2,c3>,<c3,c4>,<c4,c5>,<c5,c6>,<c6,c7>}
first (config:id) = {<c1>}
last (config:id) <= {<c1>,<c2>,<c3>,<c4>,<c5>,<c6>,<c7>}


Instance (spec:id, instance:id) = {<adventurer,a2>,<adventurer,a1>,<adventurer,a4>,<adventurer,a3>,<flashlight,fl>}
instanceInState (config:id, instance:id, state:id) >= {<c1,a2,state_adventurer_near>,<c1,a1,state_adventurer_near>,<c1,a4,state_adventurer_near>,<c1,a3,state_adventurer_near>,<c1,fl,state_flashlight_near>}<= {<c1,fl,state_flashlight_far>,<c1,fl,state_uninitialized>,<c1,fl,state_flashlight_near>,<c1,fl,state_finalized>,<c1,a1,state_adventurer_far>,<c1,a1,state_uninitialized>,<c1,a1,state_adventurer_near>,<c1,a1,state_finalized>,<c1,a2,state_adventurer_far>,<c1,a2,state_uninitialized>,<c1,a2,state_adventurer_near>,<c1,a2,state_finalized>,<c1,a3,state_adventurer_far>,<c1,a3,state_uninitialized>,<c1,a3,state_adventurer_near>,<c1,a3,state_finalized>,<c1,a4,state_adventurer_far>,<c1,a4,state_uninitialized>,<c1,a4,state_adventurer_near>,<c1,a4,state_finalized>,<c2,fl,state_flashlight_far>,<c2,fl,state_uninitialized>,<c2,fl,state_flashlight_near>,<c2,fl,state_finalized>,<c2,a1,state_adventurer_far>,<c2,a1,state_uninitialized>,<c2,a1,state_adventurer_near>,<c2,a1,state_finalized>,<c2,a2,state_adventurer_far>,<c2,a2,state_uninitialized>,<c2,a2,state_adventurer_near>,<c2,a2,state_finalized>,<c2,a3,state_adventurer_far>,<c2,a3,state_uninitialized>,<c2,a3,state_adventurer_near>,<c2,a3,state_finalized>,<c2,a4,state_adventurer_far>,<c2,a4,state_uninitialized>,<c2,a4,state_adventurer_near>,<c2,a4,state_finalized>,<c3,fl,state_flashlight_far>,<c3,fl,state_uninitialized>,<c3,fl,state_flashlight_near>,<c3,fl,state_finalized>,<c3,a1,state_adventurer_far>,<c3,a1,state_uninitialized>,<c3,a1,state_adventurer_near>,<c3,a1,state_finalized>,<c3,a2,state_adventurer_far>,<c3,a2,state_uninitialized>,<c3,a2,state_adventurer_near>,<c3,a2,state_finalized>,<c3,a3,state_adventurer_far>,<c3,a3,state_uninitialized>,<c3,a3,state_adventurer_near>,<c3,a3,state_finalized>,<c3,a4,state_adventurer_far>,<c3,a4,state_uninitialized>,<c3,a4,state_adventurer_near>,<c3,a4,state_finalized>,<c4,fl,state_flashlight_far>,<c4,fl,state_uninitialized>,<c4,fl,state_flashlight_near>,<c4,fl,state_finalized>,<c4,a1,state_adventurer_far>,<c4,a1,state_uninitialized>,<c4,a1,state_adventurer_near>,<c4,a1,state_finalized>,<c4,a2,state_adventurer_far>,<c4,a2,state_uninitialized>,<c4,a2,state_adventurer_near>,<c4,a2,state_finalized>,<c4,a3,state_adventurer_far>,<c4,a3,state_uninitialized>,<c4,a3,state_adventurer_near>,<c4,a3,state_finalized>,<c4,a4,state_adventurer_far>,<c4,a4,state_uninitialized>,<c4,a4,state_adventurer_near>,<c4,a4,state_finalized>,<c5,fl,state_flashlight_far>,<c5,fl,state_uninitialized>,<c5,fl,state_flashlight_near>,<c5,fl,state_finalized>,<c5,a1,state_adventurer_far>,<c5,a1,state_uninitialized>,<c5,a1,state_adventurer_near>,<c5,a1,state_finalized>,<c5,a2,state_adventurer_far>,<c5,a2,state_uninitialized>,<c5,a2,state_adventurer_near>,<c5,a2,state_finalized>,<c5,a3,state_adventurer_far>,<c5,a3,state_uninitialized>,<c5,a3,state_adventurer_near>,<c5,a3,state_finalized>,<c5,a4,state_adventurer_far>,<c5,a4,state_uninitialized>,<c5,a4,state_adventurer_near>,<c5,a4,state_finalized>,<c6,fl,state_flashlight_far>,<c6,fl,state_uninitialized>,<c6,fl,state_flashlight_near>,<c6,fl,state_finalized>,<c6,a1,state_adventurer_far>,<c6,a1,state_uninitialized>,<c6,a1,state_adventurer_near>,<c6,a1,state_finalized>,<c6,a2,state_adventurer_far>,<c6,a2,state_uninitialized>,<c6,a2,state_adventurer_near>,<c6,a2,state_finalized>,<c6,a3,state_adventurer_far>,<c6,a3,state_uninitialized>,<c6,a3,state_adventurer_near>,<c6,a3,state_finalized>,<c6,a4,state_adventurer_far>,<c6,a4,state_uninitialized>,<c6,a4,state_adventurer_near>,<c6,a4,state_finalized>,<c7,fl,state_flashlight_far>,<c7,fl,state_uninitialized>,<c7,fl,state_flashlight_near>,<c7,fl,state_finalized>,<c7,a1,state_adventurer_far>,<c7,a1,state_uninitialized>,<c7,a1,state_adventurer_near>,<c7,a1,state_finalized>,<c7,a2,state_adventurer_far>,<c7,a2,state_uninitialized>,<c7,a2,state_adventurer_near>,<c7,a2,state_finalized>,<c7,a3,state_adventurer_far>,<c7,a3,state_uninitialized>,<c7,a3,state_adventurer_near>,<c7,a3,state_finalized>,<c7,a4,state_adventurer_far>,<c7,a4,state_uninitialized>,<c7,a4,state_adventurer_near>,<c7,a4,state_finalized>}
raisedEvent (cur:id, nxt:id, event:id, instance:id) <= {<c1,c2,event_flashlight_crossneartofar,fl>,<c1,c2,event_flashlight_crossfartonear,fl>,<c2,c3,event_flashlight_crossneartofar,fl>,<c2,c3,event_flashlight_crossfartonear,fl>,<c3,c4,event_flashlight_crossneartofar,fl>,<c3,c4,event_flashlight_crossfartonear,fl>,<c4,c5,event_flashlight_crossneartofar,fl>,<c4,c5,event_flashlight_crossfartonear,fl>,<c5,c6,event_flashlight_crossneartofar,fl>,<c5,c6,event_flashlight_crossfartonear,fl>,<c6,c7,event_flashlight_crossneartofar,fl>,<c6,c7,event_flashlight_crossfartonear,fl>}
changedInstance (cur:id, nxt:id, instance:id) <= {<c1,c2,a1>,<c1,c2,a2>,<c1,c2,a3>,<c1,c2,a4>,<c1,c2,fl>,<c2,c3,a1>,<c2,c3,a2>,<c2,c3,a3>,<c2,c3,a4>,<c2,c3,fl>,<c3,c4,a1>,<c3,c4,a2>,<c3,c4,a3>,<c3,c4,a4>,<c3,c4,fl>,<c4,c5,a1>,<c4,c5,a2>,<c4,c5,a3>,<c4,c5,a4>,<c4,c5,fl>,<c5,c6,a1>,<c5,c6,a2>,<c5,c6,a3>,<c5,c6,a4>,<c5,c6,fl>,<c6,c7,a1>,<c6,c7,a2>,<c6,c7,a3>,<c6,c7,a4>,<c6,c7,fl>}

AdventurerTimeToCross (config:id, instance:id, timeToCross:int) >= {<c1,a2,2>,<c1,a4,10>,<c1,a1,1>,<c1,a3,5>} <= {<c2,a1,?>,<c3,a1,?>,<c4,a1,?>,<c5,a1,?>,<c6,a1,?>,<c7,a1,?>,<c2,a2,?>,<c3,a2,?>,<c4,a2,?>,<c5,a2,?>,<c6,a2,?>,<c7,a2,?>,<c2,a3,?>,<c3,a3,?>,<c4,a3,?>,<c5,a3,?>,<c6,a3,?>,<c7,a3,?>,<c2,a4,?>,<c3,a4,?>,<c4,a4,?>,<c5,a4,?>,<c6,a4,?>,<c7,a4,?>}
FlashLightTotalTimeSpend (config:id, instance:id, totalTimeSpend:int) >= {<c1,fl,0>} <= {<c2,fl,?>,<c3,fl,?>,<c4,fl,?>,<c5,fl,?>,<c6,fl,?>,<c7,fl,?>}


ParamEventFlashLightCrossNearToFarP1 (cur:id, nxt:id, p1:id) <= {<c1,c2,a1>,<c1,c2,a2>,<c1,c2,a3>,<c1,c2,a4>,<c2,c3,a1>,<c2,c3,a2>,<c2,c3,a3>,<c2,c3,a4>,<c3,c4,a1>,<c3,c4,a2>,<c3,c4,a3>,<c3,c4,a4>,<c4,c5,a1>,<c4,c5,a2>,<c4,c5,a3>,<c4,c5,a4>,<c5,c6,a1>,<c5,c6,a2>,<c5,c6,a3>,<c5,c6,a4>,<c6,c7,a1>,<c6,c7,a2>,<c6,c7,a3>,<c6,c7,a4>}
ParamEventFlashLightCrossNearToFarP2 (cur:id, nxt:id, p2:id) <= {<c1,c2,a1>,<c1,c2,a2>,<c1,c2,a3>,<c1,c2,a4>,<c2,c3,a1>,<c2,c3,a2>,<c2,c3,a3>,<c2,c3,a4>,<c3,c4,a1>,<c3,c4,a2>,<c3,c4,a3>,<c3,c4,a4>,<c4,c5,a1>,<c4,c5,a2>,<c4,c5,a3>,<c4,c5,a4>,<c5,c6,a1>,<c5,c6,a2>,<c5,c6,a3>,<c5,c6,a4>,<c6,c7,a1>,<c6,c7,a2>,<c6,c7,a3>,<c6,c7,a4>}
ParamEventFlashLightCrossFarToNearP (cur:id, nxt:id, p:id) <= {<c1,c2,a1>,<c1,c2,a2>,<c1,c2,a3>,<c1,c2,a4>,<c2,c3,a1>,<c2,c3,a2>,<c2,c3,a3>,<c2,c3,a4>,<c3,c4,a1>,<c3,c4,a2>,<c3,c4,a3>,<c3,c4,a4>,<c4,c5,a1>,<c4,c5,a2>,<c4,c5,a3>,<c4,c5,a4>,<c5,c6,a1>,<c5,c6,a2>,<c5,c6,a3>,<c5,c6,a4>,<c6,c7,a1>,<c6,c7,a2>,<c6,c7,a3>,<c6,c7,a4>}

// Constraints for the configuration and ordering relations
order ⊆ Config[config as cur] ⨯ Config[config as nxt]
last = Config ∖ order[cur->config]  // There is only one last configuration
 

// Generic 'Type' constraints    
raisedEvent ⊆ (order) ⨯ allowedTransitions[event] ⨯ Instance[instance]
instanceInState ⊆ Instance[instance] ⨯ Config ⨯ State
changedInstance ⊆ (order) ⨯ Instance[instance]
    
// Machine specific `type` constraints
AdventurerTimeToCross[config,instance]  ⊆ Config ⨯ (Instance ⨝ Adventurer)[instance]
FlashLightTotalTimeSpend[config,instance]  ⊆ Config ⨯ (Instance ⨝ FlashLight)[instance]

ParamEventFlashLightCrossNearToFarP1 ⊆ (order) ⨯ (Instance ⨝ Adventurer)[instance->p1]
ParamEventFlashLightCrossNearToFarP2 ⊆ (order) ⨯ (Instance ⨝ Adventurer)[instance->p2]
ParamEventFlashLightCrossFarToNearP ⊆ (order) ⨯ (Instance ⨝ Adventurer)[instance->p]

// Specific per event
∀ step ∈ (order) ⨝ raisedEvent | (
  (some (step ⨝ EventFlashLightCrossNearToFar) ⇔ one (step ⨝ ParamEventFlashLightCrossNearToFarP1)) ∧
  (some (step ⨝ EventFlashLightCrossNearToFar) ⇔ one (step ⨝ ParamEventFlashLightCrossNearToFarP2)) ∧
  (some (step ⨝ EventFlashLightCrossFarToNear) ⇔ one (step ⨝ ParamEventFlashLightCrossFarToNearP))
)

// Generic: All configurations are reachable
∀ c ∈ Config ∖ first | c ⊆ (first[config as cur] ⨝ ^<cur,nxt>order)[nxt -> config]

// Generic: Every transition can only happen by exactly one event
∀ o ∈ order | one o ⨝ raisedEvent

// Specif: In every configuration all machines have a state IFF its a machine which is not empty
∀ c ∈ Config, inst ∈ Instance | one instanceInState ⨝ c ⨝ inst

// Specific per machine: In every configuration iff a machine is in an initialized state then it must have values
∀ c ∈ Config, inst ∈ (Instance ⨝ Adventurer)[instance] | (((c ⨯ inst) ⨝ instanceInState)[state] ⊆ initialized ⇔ one AdventurerTimeToCross ⨝ c ⨝ inst)
∀ c ∈ Config, inst ∈ (Instance ⨝ FlashLight)[instance] | (((c ⨯ inst) ⨝ instanceInState)[state] ⊆ initialized ⇔ one FlashLightTotalTimeSpend ⨝ c ⨝ inst)


// Generic: Transitions are only allowed between if an event is specified between two states
∀ o ∈ (order) ⨝ raisedEvent | (o[cur as config] ⨝ instanceInState)[state->from] ⨯ (o[nxt as config] ⨝ instanceInState)[state->to] ⨯ o[event] ⊆ allowedTransitions

// Change set predicates
pred inChangeSet[step: (cur:id, nxt:id), instances: (instance:id)]
  = instances ⊆ (changedInstance ⨝ step)[instance]
 
pred notInChangeSet[step: (cur:id, nxt:id), instances: (instance:id)]
  = no instances ∩ (changedInstance ⨝ step)[instance]

pred changeSetCanContain[step: (cur:id, nxt:id), instances: (instance:id)]
  = (changedInstance ⨝ step)[instance] ⊆ instances 

// Generic predicates
pred forceState[curState: (state:id), nxtState: (state:id), raisedEvent: (event:id)]
  = nxtState = (curState[state as from] ⨝ (allowedTransitions ⨝ raisedEvent))[to->state]

pred inState[config: (config:id), instance: (instance:id), state: (state:id)]
  = ((instance ⨯ config) ⨝ instanceInState)[state] ⊆ state

pred eventAdventurerCross[step:(cur:id, nxt:id), adventurer: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ adventurer)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ adventurer)[state] |
    ( 
       
      // Postconditions
      (some ((adventurer ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as cur_timeToCross] ⨯ (adventurer ⨝ (AdventurerTimeToCross ⨝ nxt))[timeToCross][timeToCross as nxt_timeToCross]) where (nxt_timeToCross = cur_timeToCross))  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventAdventurerCross] ∧
      // Make sure this instance is in the change set
      inChangeSet[step, adventurer]
    )

pred frameAdventurer[step: (cur:id, nxt:id), adventurer: (instance:id)] 
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ adventurer)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ adventurer)[state] | (
    nxtState = curState ∧
    (
      curState ⊆ uninitialized ∨ 
      (// Postconditions
       (some ((adventurer ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as cur_timeToCross] ⨯ (adventurer ⨝ (AdventurerTimeToCross ⨝ nxt))[timeToCross][timeToCross as nxt_timeToCross]) where (nxt_timeToCross = cur_timeToCross)))
    )
  )


pred possibleTransitionsAdventurer[step: (cur:id, nxt:id)] 
  = ∀ inst ∈ (Instance ⨝ Adventurer)[instance] |
    
    (notInChangeSet[step, inst] ⇒ frameAdventurer[step, inst])

pred eventFlashLightCrossNearToFar[step:(cur:id, nxt:id), flashlight: (instance:id), p1: (instance:id), p2: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ flashlight)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ flashlight)[state] |
    ( 
      // Preconditions 
      inState[cur, p1, StateAdventurerNear] ∧
      inState[cur, p2, StateAdventurerNear] ∧
      eventAdventurerCross[step, p1] ∧
      eventAdventurerCross[step, p2]  ∧ 
      // Postconditions
      ((((some ((p2 ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as param_2_timeToCross] ⨯ (p1 ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as param_1_timeToCross]) where (param_1_timeToCross > param_2_timeToCross)) ⇒ (some ((flashlight ⨝ (FlashLightTotalTimeSpend ⨝ nxt))[totalTimeSpend][totalTimeSpend as nxt_totalTimeSpend] ⨯ (p1 ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as param_3_timeToCross] ⨯ (flashlight ⨝ (FlashLightTotalTimeSpend ⨝ cur))[totalTimeSpend][totalTimeSpend as cur_totalTimeSpend]) where (nxt_totalTimeSpend = cur_totalTimeSpend + param_3_timeToCross)))) ∧ ((¬ (((some ((p2 ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as param_5_timeToCross] ⨯ (p1 ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as param_4_timeToCross]) where (param_4_timeToCross > param_5_timeToCross)))) ⇒ (some ((flashlight ⨝ (FlashLightTotalTimeSpend ⨝ cur))[totalTimeSpend][totalTimeSpend as cur_totalTimeSpend] ⨯ (p2 ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as param_6_timeToCross] ⨯ (flashlight ⨝ (FlashLightTotalTimeSpend ⨝ nxt))[totalTimeSpend][totalTimeSpend as nxt_totalTimeSpend]) where (nxt_totalTimeSpend = cur_totalTimeSpend + param_6_timeToCross)))))  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventFlashLightCrossNearToFar] ∧
      // Make sure this instance is in the change set
      inChangeSet[step, flashlight]
    )

pred frameFlashLight[step: (cur:id, nxt:id), flashlight: (instance:id)] 
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ flashlight)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ flashlight)[state] | (
    nxtState = curState ∧
    (
      curState ⊆ uninitialized ∨ 
      (// Postconditions
       (some ((flashlight ⨝ (FlashLightTotalTimeSpend ⨝ nxt))[totalTimeSpend][totalTimeSpend as nxt_totalTimeSpend] ⨯ (flashlight ⨝ (FlashLightTotalTimeSpend ⨝ cur))[totalTimeSpend][totalTimeSpend as cur_totalTimeSpend]) where (nxt_totalTimeSpend = cur_totalTimeSpend)))
    )
  )

pred eventFlashLightCrossFarToNear[step:(cur:id, nxt:id), flashlight: (instance:id), p: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ flashlight)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ flashlight)[state] |
    ( 
      // Preconditions 
      inState[cur, p, StateAdventurerFar] ∧
      eventAdventurerCross[step, p]  ∧ 
      // Postconditions
      (some ((flashlight ⨝ (FlashLightTotalTimeSpend ⨝ nxt))[totalTimeSpend][totalTimeSpend as nxt_totalTimeSpend] ⨯ (p ⨝ (AdventurerTimeToCross ⨝ cur))[timeToCross][timeToCross as param_1_timeToCross] ⨯ (flashlight ⨝ (FlashLightTotalTimeSpend ⨝ cur))[totalTimeSpend][totalTimeSpend as cur_totalTimeSpend]) where (nxt_totalTimeSpend >= cur_totalTimeSpend + param_1_timeToCross))  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventFlashLightCrossFarToNear] ∧
      // Make sure this instance is in the change set
      inChangeSet[step, flashlight]
    )


pred possibleTransitionsFlashLight[step: (cur:id, nxt:id)] 
  = ∀ inst ∈ (Instance ⨝ FlashLight)[instance] |
    (some inst ∩ ((raisedEvent ⨝ step)[instance]) ⇔ (
      (eventFlashLightCrossNearToFar[step,inst,(step ⨝ ParamEventFlashLightCrossNearToFarP1)[p1->instance],(step ⨝ ParamEventFlashLightCrossNearToFarP2)[p2->instance]] ∧
      (step ⨝ raisedEvent)[event] = EventFlashLightCrossNearToFar ∧
      let cur = step[cur->config], p1 = (ParamEventFlashLightCrossNearToFarP1 ⨝ step)[p1 -> instance], p2 = (ParamEventFlashLightCrossNearToFarP2 ⨝ step)[p2 -> instance] | changeSetCanContain[step, p1 ∪ p2 ∪ inst])
      ∨
      (eventFlashLightCrossFarToNear[step,inst,(step ⨝ ParamEventFlashLightCrossFarToNearP)[p->instance]] ∧
      (step ⨝ raisedEvent)[event] = EventFlashLightCrossFarToNear ∧
      let cur = step[cur->config], p = (ParamEventFlashLightCrossFarToNearP ⨝ step)[p -> instance] | changeSetCanContain[step, inst ∪ p])
    ))
    ∧
    (notInChangeSet[step, inst] ⇒ frameFlashLight[step, inst])


// Transition function
∀ step ∈ order| possibleTransitionsAdventurer[step] ∧ possibleTransitionsFlashLight[step]



// Assert: EverybodyCrossedInTheLeastTime
∃ cur_1 ∈ Config | let step_1 = (cur_1[config as cur] ⨝ (order)) | ((((∀ a ∈ (Instance ⨝ Adventurer)[instance] | inState[cur_1, a, StateAdventurerFar])) ∧ ((∃ fl ∈ (Instance ⨝ FlashLight)[instance] | (some ((fl ⨝ (FlashLightTotalTimeSpend ⨝ cur_1))[totalTimeSpend][totalTimeSpend as fl]) where (fl = 17))))))



// Minimize the number of steps by minimizing the number of Configurations
objectives: minimize Config[count()]