// Static configuration of state machines
// Define the specs that can take place in the transition system
Boolean (spec:id) = {<boolean>}
Light (spec:id) = {<light>}

// Define all possible states for all machines
State (state:id) = {<state_uninitialized>,<state_finalized>,<state_light_lightoff>,<state_light_lighton>}
initialized (state:id) = {<state_light_lightoff>,<state_light_lighton>}
finalized (state:id) = {<state_finalized>}
uninitialized (state:id) = {<state_uninitialized>}

StateLightLightOn (state:id) = {<state_light_lighton>}StateLightLightOff (state:id) = {<state_light_lightoff>}

// Define which transitions are allowed (in the form of `from a state` -> ` via an event` -> `to a state`
allowedTransitions (from:id, to:id, event:id) = {<state_light_lighton,state_light_lightoff,event_light_switchoff>,<state_uninitialized,state_light_lighton,event_light_switchon>,<state_light_lightoff,state_light_lighton,event_light_switchon>}
// Define each event as single relation so that the events can be used as variables in the constraints 
EventLightSwitchOn (event:id) = {<event_light_switchon>}
EventLight__frame (event:id) = {<event_light___frame>}
EventLightSwitchOff (event:id) = {<event_light_switchoff>}


// Dynamic configuration of state machines
Config (config:id) >= {<c1>} <= {<c1>,<c2>,<c3>,<c4>,<c5>}
order (cur:id, nxt:id) <= {<c1,c2>,<c2,c3>,<c3,c4>,<c4,c5>}
first (config:id) = {<c1>}
last (config:id) <= {<c1>,<c2>,<c3>,<c4>,<c5>}
back (config:id) <= {<c1>,<c2>,<c3>,<c4>,<c5>}
loop (cur:id, nxt:id) <= {<c2,c1>,<c2,c2>,<c3,c1>,<c3,c2>,<c3,c3>,<c4,c1>,<c4,c2>,<c4,c3>,<c4,c4>,<c5,c1>,<c5,c2>,<c5,c3>,<c5,c4>,<c5,c5>}

Instance (spec:id, instance:id) = {<light,l1>,<boolean,TRUE>,<boolean,maybe>,<boolean,FALSE>,<boolean,MAYBE>}
instanceInState (config:id, instance:id, state:id) >= {<c1,l1,state_uninitialized>}<= {<c1,l1,state_uninitialized>,<c1,l1,state_light_lightoff>,<c1,l1,state_finalized>,<c1,l1,state_light_lighton>,<c2,l1,state_uninitialized>,<c2,l1,state_light_lightoff>,<c2,l1,state_finalized>,<c2,l1,state_light_lighton>,<c3,l1,state_uninitialized>,<c3,l1,state_light_lightoff>,<c3,l1,state_finalized>,<c3,l1,state_light_lighton>,<c4,l1,state_uninitialized>,<c4,l1,state_light_lightoff>,<c4,l1,state_finalized>,<c4,l1,state_light_lighton>,<c5,l1,state_uninitialized>,<c5,l1,state_light_lightoff>,<c5,l1,state_finalized>,<c5,l1,state_light_lighton>}
raisedEvent (cur:id, nxt:id, event:id, instance:id) <= {<c1,c2,event_light_switchon,l1>,<c1,c2,event_light_switchoff,l1>,<c2,c3,event_light_switchon,l1>,<c2,c3,event_light_switchoff,l1>,<c3,c4,event_light_switchon,l1>,<c3,c4,event_light_switchoff,l1>,<c4,c5,event_light_switchon,l1>,<c4,c5,event_light_switchoff,l1>}
changedInstance (cur:id, nxt:id, instance:id) <= {<c1,c2,l1>,<c2,c3,l1>,<c3,c4,l1>,<c4,c5,l1>}

LightSwitch (config:id, instance:id, switch:id) <= {<c1,l1,FALSE>,<c1,l1,TRUE>,<c1,l1,MAYBE>,<c1,l1,maybe>,<c2,l1,FALSE>,<c2,l1,TRUE>,<c2,l1,MAYBE>,<c2,l1,maybe>,<c3,l1,FALSE>,<c3,l1,TRUE>,<c3,l1,MAYBE>,<c3,l1,maybe>,<c4,l1,FALSE>,<c4,l1,TRUE>,<c4,l1,MAYBE>,<c4,l1,maybe>,<c5,l1,FALSE>,<c5,l1,TRUE>,<c5,l1,MAYBE>,<c5,l1,maybe>}

Boolean_TRUE (instance:id) = {<TRUE>}
Boolean_FALSE (instance:id) = {<FALSE>}
Boolean_MAYBE (instance:id) = {<MAYBE>}



// Constraints for the configuration and ordering relations
order ⊆ Config[config as cur] ⨯ Config[config as nxt]
last = Config ∖ order[cur->config]  // There is only one last configuration
back ⊆ Config 
lone back   
loop ⊆ last[config as cur] ⨯ back[config as nxt] // Loop contains at most one tuple going back from the last configuration to the 

// Generic 'Type' constraints    
raisedEvent ⊆ order ⨯ allowedTransitions[event] ⨯ Instance[instance]
instanceInState ⊆ Instance[instance] ⨯ Config ⨯ State
changedInstance ⊆ order ⨯ Instance[instance]
    
// Machine specific `type` constraints
LightSwitch  ⊆ Config ⨯ (Instance ⨝ Light)[instance] ⨯ (Instance ⨝ Boolean)[instance->switch]




// Generic: All configurations are reachable
∀ c ∈ Config ∖ first | c ⊆ (first[config as cur] ⨝ ^<cur,nxt>order)[nxt -> config]

// Generic: Every transition can only happen by exactly one event
∀ o ∈ order | one o ⨝ raisedEvent

// Specif: In every configuration all machines have a state IFF its a machine which is not empty
∀ c ∈ Config, inst ∈ (Instance ∖ ((Boolean) ⨝ Instance)) | one instanceInState ⨝ c ⨝ inst

// Specific per machine: In every configuration iff a machine is in an initialized state then it must have values
∀ c ∈ Config, inst ∈ (Instance ⨝ Light)[instance] | (no (((c ⨯ inst) ⨝ instanceInState)[state] ∩ initialized) ⇒ no LightSwitch ⨝ c ⨝ inst)
∀ c ∈ Config, inst ∈ (Instance ⨝ Light)[instance] | (((c ⨯ inst) ⨝ instanceInState)[state] ⊆ initialized ⇒ one LightSwitch ⨝ c ⨝ inst)


// Generic: Transitions are only allowed between if an event is specified between two states
∀ o ∈ order ⨝ raisedEvent | (o[cur as config] ⨝ instanceInState)[state->from] ⨯ (o[nxt as config] ⨝ instanceInState)[state->to] ⨯ o[event] ⊆ allowedTransitions

// Generic predicates
pred forceState[curState: (state:id), nxtState: (state:id), raisedEvent: (event:id)]
  = nxtState = (curState[state as from] ⨝ (allowedTransitions ⨝ raisedEvent))[to->state]

pred inState[config: (config:id), instance: (instance:id), state: (state:id)]
  = ((instance ⨯ config) ⨝ instanceInState)[state] ⊆ state

pred eventLightSwitchOn[step:(cur:id, nxt:id), light: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ light)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ light)[state],
        curSwitch = (cur ⨝ LightSwitch ⨝ light)[switch],
        nxtSwitch = (nxt ⨝ LightSwitch ⨝ light)[switch] |
    ( 
       
      // Postconditions
      nxtSwitch = Boolean_TRUE[instance as switch]  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventLightSwitchOn] ∧
      // Make sure this instance is in the change set
      light ⊆ (changedInstance ⨝ step)[instance]
    )

pred eventLightSwitchOff[step:(cur:id, nxt:id), light: (instance:id)]
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ light)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ light)[state],
        curSwitch = (cur ⨝ LightSwitch ⨝ light)[switch],
        nxtSwitch = (nxt ⨝ LightSwitch ⨝ light)[switch] |
    ( 
      // Preconditions 
      curSwitch = Boolean_TRUE[instance as switch]  ∧ 
      // Postconditions
      nxtSwitch = Boolean_FALSE[instance as switch]  ∧ 
      // Generic event conditions
      forceState[curState, nxtState, EventLightSwitchOff] ∧
      // Make sure this instance is in the change set
      light ⊆ (changedInstance ⨝ step)[instance]
    )

pred frameLight[step: (cur:id, nxt:id), light: (instance:id)] 
  = let cur = step[cur->config],
        nxt = step[nxt->config],
        curState = (instanceInState ⨝ cur ⨝ light)[state],
        nxtState = (instanceInState ⨝ nxt ⨝ light)[state],
        curSwitch = (cur ⨝ LightSwitch ⨝ light)[switch],
        nxtSwitch = (nxt ⨝ LightSwitch ⨝ light)[switch] | (
    nxtState = curState ∧
    (
      curState ⊆ uninitialized ∨ 
      (// Postconditions
       nxtSwitch = curSwitch)
    )
  )


pred possibleTransitionsLight[step: (cur:id, nxt:id)] 
  = ∀ inst ∈ (Instance ⨝ Light)[instance] |
    (some inst ∩ ((raisedEvent ⨝ step)[instance]) ⇔ (
      (eventLightSwitchOn[step,inst] ∧
      (step ⨝ raisedEvent)[event] = EventLightSwitchOn ∧
      (changedInstance ⨝ step)[instance] ⊆ inst)
      ∨
      (eventLightSwitchOff[step,inst] ∧
      (step ⨝ raisedEvent)[event] = EventLightSwitchOff ∧
      (changedInstance ⨝ step)[instance] ⊆ inst)
    ))
    ∧
    (no inst ∩ (changedInstance ⨝ step)[instance] ⇒ frameLight[step, inst])


// Transition function
∀ step ∈ order | possibleTransitionsLight[step]


// Asserts: this is where the checks get added
∃ cur ∈ Config | (∃ l ∈ (Light ⨝ Instance)[instance] | let step = (order ⨝ cur[config as cur]), prev = cur, cur = step[nxt->config] | EventLightSwitchOff ⊆ (raisedEvent ⨝ step ⨝ l)[event])

// Minimize the number of steps by minimizing the number of Configurations
objectives: minimize Config[count()]
