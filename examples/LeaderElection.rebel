module LeaderElection

import lib::Id
    
spec Process
  id: Id,
  succ: Process,
  toSend: set Id;

  internal event receive(someId: Id) 
    post:  
      this.toSend' = {id: this.toSend | id.greaterThan(someId)} + someId;

    variant notElected
      pre: this.id != someId; 
    
    variant elected  
      pre: someId = this.id;  
  
  event send(someId: Id)
    pre: someId in this.toSend, this.succ.receive(someId);
    post: this.toSend' = this.toSend - someId; 
    
  states:
    notElected -> notElected: send, receive::notElected; 
    notElected -> elected: receive::elected;

fact AlwaysInitializedIds
  = always forall id: Id | id is initialized;
    
config RingOfThree
  = id1,id2,id3: Id is created,
    p1,p2,p3: Process is notElected, 
    p1 with id = id1, succ = p2, toSend = {id1},
    p2 with id = id2, succ = p3, toSend = {id2},
    p3 with id = id3, succ = p1, toSend = {id3};
    
assert EventuallyOneIsElected
  = eventually exists p: Process | p is elected;

assert OnlyOneCanGetElected
  = eventually exists p1,p2: Process | p1 is elected && p2 is elected && p1 != p2;  
  
check EventuallyOneIsElected starting at RingOfThree in max 5 steps;  
