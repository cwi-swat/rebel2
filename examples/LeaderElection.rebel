module LeaderElection

import lib::Id
    
spec Process
  id: Id,
  succ: Process,
  toSend: set Id;

  internal event receive(someId: Id) 
    pre: this.id != someId;
    post: 
      forall id: this.toSend | (this.id.lesserThan(someId) => id notin this.toSend'), 
      someId in this.toSend';
      
  internal event receiveElected(someId: Id)
    pre: someId = this.id;  
    post: 
      forall id: this.toSend | (this.id.lesserThan(someId) => id notin this.toSend'), 
      someId in this.toSend';
  
  event send(someId: Id)
    pre: someId in this.toSend, (this.succ.receive(someId) || this.succ.receiveElected(someId));
    post: this.toSend' = this.toSend - someId; 
    
  states:
    notElected -> notElected: send, receive;
    notElected -> elected: receiveElected;

    
config RingOfThree
  = id1,id2,id3: Id is created,
    p1,p2,p3: Process is notElected, 
    p1 with id = id1, succ = p2, toSend = {id1},
    p2 with id = id2, succ = p3, toSend = {id2},
    p3 with id = id3, succ = p1, toSend = {id3};
    
assert EventuallyOneIsElected
  = eventually exists p: Process | p is elected;

assert OnlyOneCanGetElected
  = always (exists p1,p2: Process | (p1 is elected && p2 is elected) => p1 = p2);  
  
check EventuallyOneIsElected starting at RingOfThree in max 5 steps;  
