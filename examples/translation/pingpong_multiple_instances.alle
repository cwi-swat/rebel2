// Static configuration of state machines
Spec (spId:id) = {<pingpong>}
states (spId:id, stId:id) = {<pingpong,uninitialized>, <pingpong,finalized>, <pingpong,pingpong_ping>, <pingpong,pingpong_pong>}
initialized (stId:id) = {<pingpong_ping>,<pingpong_pong>}

PingPongEventStart (event:id) = {<pingpong_event_start>}
PingPongEventHit (event:id)   = {<pingpong_event_hit>} 

events (from:id, to:id, event:id) = {
  <uninitialized, pingpong_ping, pingpong_event_start>,
  <pingpong_ping, pingpong_pong, pingpong_event_hit>,
  <pingpong_pong, pingpong_ping, pingpong_event_hit>
  }
MachinePingPong (spId:id) = {<pingpong>}

// Dynamic part
Instance (spId:id, iId:id) = {<pingpong,p1>,<pingpong,p2>} // There are two machines; p1 and p2
instanceInState (cId:id, iId:id, stId:id) >= {<c1,p1,uninitialized>,<c1,p2,uninitialized>} <= {<c1,p1,uninitialized>..<c9,p2,uninitialized>, <c1,p1,finalized>..<c9,p2,finalized>, <c1,p1,pingpong_ping>..<c9,p2,pingpong_ping>, <c1,p1,pingpong_pong>..<c9,p2,pingpong_pong>}

Config (cId:id) >= {<c1>} <= {<c1>..<c9>}
configOrder (cur:id, nxt:id) <= {<c1,c2>,<c2,c3>,<c3,c4>,<c4,c5>,<c5,c6>,<c6,c7>,<c7,c8>,<c8,c9>}
initialConfig (cId:id) = {<c1>}
finalConfig (cId:id) <= {<c1>..<c9>}

raisedEvent (cur:id, nxt:id, event:id, iId:id) <= {
  <c1,c2,pingpong_event_start,p1>,<c1,c2,pingpong_event_start,p2>,<c1,c2,pingpong_event_hit,p1>,<c1,c2,pingpong_event_hit,p2>,
  <c2,c3,pingpong_event_start,p1>,<c2,c3,pingpong_event_start,p2>,<c2,c3,pingpong_event_hit,p1>,<c2,c3,pingpong_event_hit,p2>,
  <c3,c4,pingpong_event_start,p1>,<c3,c4,pingpong_event_start,p2>,<c3,c4,pingpong_event_hit,p1>,<c3,c4,pingpong_event_hit,p2>,
  <c4,c5,pingpong_event_start,p1>,<c4,c5,pingpong_event_start,p2>,<c4,c5,pingpong_event_hit,p1>,<c4,c5,pingpong_event_hit,p2>,
  <c5,c6,pingpong_event_start,p1>,<c5,c6,pingpong_event_start,p2>,<c5,c6,pingpong_event_hit,p1>,<c5,c6,pingpong_event_hit,p2>,
  <c6,c7,pingpong_event_start,p1>,<c6,c7,pingpong_event_start,p2>,<c6,c7,pingpong_event_hit,p1>,<c6,c7,pingpong_event_hit,p2>,
  <c7,c8,pingpong_event_start,p1>,<c7,c8,pingpong_event_start,p2>,<c7,c8,pingpong_event_hit,p1>,<c7,c8,pingpong_event_hit,p2>,
  <c8,c9,pingpong_event_start,p1>,<c8,c9,pingpong_event_start,p2>,<c8,c9,pingpong_event_hit,p1>,<c8,c9,pingpong_event_hit,p2>
}

PingPongStateVector (cId:id, iId:id, id:int, times:int) >= {<c1,p1,0,0>,<c1,p2,0,0>} <= {<c2,p1,?,?>..<c9,p2,?,?>}
ParamsEventPingPongStart (cur:id, nxt:id, id:int) <= {<c1,c2,?>,<c2,c3,?>,<c3,c4,?>,<c4,c5,?>,<c5,c6,?>,<c6,c7,?>,<c7,c8,?>,<c8,c9,?>}

// 'Type' constraints
configOrder ⊆ Config[cId as cur] ⨯ Config[cId as nxt]
raisedEvent ⊆ configOrder ⨯ events[event] ⨯ Instance[iId]

instanceInState ⊆ Instance[iId] ⨯ Config ⨯ states[stId]
PingPongStateVector[cId,iId] ⊆ Config ⨯ Instance[iId]

ParamsEventPingPongStart[cur,nxt] ⊆ configOrder
 
// All configurations are reachable
∀ c ∈ Config ∖ initialConfig | c ⊆ (initialConfig[cId as cur] ⨝ ^<cur,nxt>configOrder)[nxt -> cId]

finalConfig ⊆ Config
one finalConfig
no finalConfig[cId as cur] ⨝ configOrder
 
// Every transition can only happen by exactly one event
∀ o ∈ configOrder | one o ⨝ raisedEvent

// In every configuration all machines have a state
∀ c ∈ Config, inst ∈ Instance | one instanceInState ⨝ c ⨝ inst

// In every configuration all PingPongMachines have values
∀ c ∈ Config, ppInst ∈ PingPongStateVector[iId] | one PingPongStateVector ⨝ c ⨝ ppInst

// Transitions are only allowed between if an event is specified between two states
∀ o ∈ configOrder ⨝ raisedEvent | (o[cur as cId] ⨝ instanceInState)[stId->from] ⨯ (o[nxt as cId] ⨝ instanceInState)[stId->to] ⨯ o[event] ⊆ events
   
// Transition function
∀ o ∈ configOrder |  
  ∀ inst ∈ PingPongStateVector[iId] |  
    let old = (o[cur as cId] ⨝ PingPongStateVector ⨝ instanceInState ⨝ inst)[cId -> oldCId, stId->oldStId, id->oldId, times->oldTimes],
        new = (o[nxt as cId] ⨝ PingPongStateVector ⨝ instanceInState ⨝ inst)[cId -> newCId, stId->newStId, id->newId, times->newTimes, iId->newIId] | 
    (some new[newIId->iId] ∩ ((raisedEvent ⨝ o)[iId]) ⇔ ( 
      (
        some (new ⨯ (o ⨝ ParamsEventPingPongStart)) where (id > 0 && newId = id) ∧ 
        some (new where newTimes = 0) ∧
        (o ⨝ raisedEvent)[event] = PingPongEventStart ∧ 
        new[newStId] = (old[oldStId as from] ⨝ (events ⨝ PingPongEventStart))[to->newStId]  
      ) 
      ////////////////
      ∨ 
      // PingPong.hit()
      ( 
        (o ⨝ raisedEvent)[event] = PingPongEventHit ∧ 
        some (new ⨯ old) where (newTimes = oldTimes + 1 && newId = oldId) ∧ 
        new[newStId] = (old[oldStId as from] ⨝ (events ⨝ PingPongEventHit))[to->newStId]  
      ) 
      ////////////////
    )) 
    ∧ 
    // If it is not the changing instance, frame the values
    (no new[newIId->iId] ∩ (raisedEvent ⨝ o)[iId] ⇔ ( 
      some (new ⨯ old) where (newTimes = oldTimes && newId = oldId) ∧ 
      new[newStId] = old[oldStId->newStId]
    ))

// unique id's
∀ p ∈ PingPongStateVector, pp ∈ PingPongStateVector ∖ p | 
  ((p ∪ pp) ⨝ instanceInState)[stId] ⊆ initialized ⇒ (p[id] = pp[id] ⇒ p[iId] = pp[iId]) 

//∀ p ∈ PingPongStateVector[iId,id], pp ∈ PingPongStateVector[iId,id] | ((p ∪ pp) ⨝ instanceInState)[stId] ⊆ initialized ⇒ 
//  ((p[id] = pp[id]) ⇒ (p = p))
  
∀ pp ∈ (finalConfig ⨝ PingPongStateVector) | some pp where times = 3

objectives: minimize Config[count()], minimize ParamsEventPingPongStart[count()]
     