// Static configuration of state machines
State (stId:id) = {<uninitialized>, <finalized>, <pingpong_ping>, <pingpong_pong>}
initialized (stId:id) = {<pingpong_ping>,<pingpong_pong>}
finalized (stId:id) = {<finalized>}
uninitialized (stId:id) = {<uninitialized>}

PingPongEventStart (event:id) = {<pingpong_event_start>}
PingPongEventHit (event:id)   = {<pingpong_event_hit>} 

allowedTransitions (from:id, to:id, event:id) = {
  <uninitialized, pingpong_ping, pingpong_event_start>,
  <pingpong_ping, pingpong_pong, pingpong_event_hit>,
  <pingpong_pong, pingpong_ping, pingpong_event_hit>
}

_PingPong (spec:id) = {<pingpong>}

// Dynamic part
Instance (spec:id, iId:id) = {<pingpong,p1>,<pingpong,p2>} // There are two machines; p1 and p2
instanceInState (cId:id, iId:id, stId:id) >= {<c1,p1,uninitialized>,<c1,p2,uninitialized>} <= {<c1,p1,uninitialized>..<c9,p2,uninitialized>, <c1,p1,finalized>..<c9,p2,finalized>, <c1,p1,pingpong_ping>..<c9,p2,pingpong_ping>, <c1,p1,pingpong_pong>..<c9,p2,pingpong_pong>}

Config (cId:id) >= {<c1>} <= {<c1>..<c9>}
configOrder (cur:id, nxt:id) <= {<c1,c2>,<c2,c3>,<c3,c4>,<c4,c5>,<c5,c6>,<c6,c7>,<c7,c8>,<c8,c9>}
initialConfig (cId:id) = {<c1>}

raisedEvent (cur:id, nxt:id, event:id, iId:id) <= {
  <c1,c2,pingpong_event_start,p1>,<c1,c2,pingpong_event_start,p2>,<c1,c2,pingpong_event_hit,p1>,<c1,c2,pingpong_event_hit,p2>,
  <c2,c3,pingpong_event_start,p1>,<c2,c3,pingpong_event_start,p2>,<c2,c3,pingpong_event_hit,p1>,<c2,c3,pingpong_event_hit,p2>,
  <c3,c4,pingpong_event_start,p1>,<c3,c4,pingpong_event_start,p2>,<c3,c4,pingpong_event_hit,p1>,<c3,c4,pingpong_event_hit,p2>,
  <c4,c5,pingpong_event_start,p1>,<c4,c5,pingpong_event_start,p2>,<c4,c5,pingpong_event_hit,p1>,<c4,c5,pingpong_event_hit,p2>,
  <c5,c6,pingpong_event_start,p1>,<c5,c6,pingpong_event_start,p2>,<c5,c6,pingpong_event_hit,p1>,<c5,c6,pingpong_event_hit,p2>,
  <c6,c7,pingpong_event_start,p1>,<c6,c7,pingpong_event_start,p2>,<c6,c7,pingpong_event_hit,p1>,<c6,c7,pingpong_event_hit,p2>,
  <c7,c8,pingpong_event_start,p1>,<c7,c8,pingpong_event_start,p2>,<c7,c8,pingpong_event_hit,p1>,<c7,c8,pingpong_event_hit,p2>,
  <c8,c9,pingpong_event_start,p1>,<c8,c9,pingpong_event_start,p2>,<c8,c9,pingpong_event_hit,p1>,<c8,c9,pingpong_event_hit,p2>
}

changedInstance (cur:id, nxt:id, iId:id) <= {<c1,c2,p1>,<c1,c2,p2>,<c2,c3,p1>,<c2,c3,p2>,<c3,c4,p1>,<c3,c4,p2>,<c4,c5,p1>,<c4,c5,p2>,<c5,c6,p1>,<c5,c6,p2>,<c6,c7,p1>,<c6,c7,p2>,<c7,c8,p1>,<c7,c8,p2>,<c8,c9,p1>,<c8,c9,p2>}

//PingPongStateVector (cId:id, iId:id, id:int, times:int) >= {<c1,p1,0,0>,<c1,p2,0,0>} <= {<c2,p1,?,?>..<c9,p2,?,?>}
PingPongStateVector (cId:id, iId:id, id:int, times:int) <= {<c1,p1,?,?>..<c9,p2,?,?>}

ParamsEventPingPongStart (cur:id, nxt:id, id:int) <= {<c1,c2,?>,<c2,c3,?>,<c3,c4,?>,<c4,c5,?>,<c5,c6,?>,<c6,c7,?>,<c7,c8,?>,<c8,c9,?>}

// 'Type' constraints
// Generic type constraints
configOrder ⊆ Config[cId as cur] ⨯ Config[cId as nxt]
raisedEvent ⊆ configOrder ⨯ allowedTransitions[event] ⨯ Instance[iId]
instanceInState ⊆ Instance[iId] ⨯ Config ⨯ State
changedInstance ⊆ configOrder ⨯ Instance[iId]

// Machine specific type constraints
PingPongStateVector[cId,iId] ⊆ Config ⨯ Instance[iId]
ParamsEventPingPongStart[cur,nxt] ⊆ configOrder
 
// Generic: All configurations are reachable
∀ c ∈ Config ∖ initialConfig | c ⊆ (initialConfig[cId as cur] ⨝ ^<cur,nxt>configOrder)[nxt -> cId]
 
// Generic: Every transition can only happen by exactly one event
∀ o ∈ configOrder | one o ⨝ raisedEvent

// Generic: In every configuration all machines have a state
∀ c ∈ Config, inst ∈ Instance | one instanceInState ⨝ c ⨝ inst

// Specific per machine: In every configuration iff a PingPong machine is in an initialized state then it must have values
∀ c ∈ Config, inst ∈ (Instance ⨝ _PingPong)[iId] | (((c ⨯ inst) ⨝ instanceInState)[stId] ⊆ initialized ⇒ one PingPongStateVector ⨝ c ⨝ inst)
//∀ c ∈ Config ∖ initialConfig, inst ∈ (Instance ⨝ PingPong)[iId] | one PingPongStateVector ⨝ c ⨝ inst

// Generic: Transitions are only allowed between if an event is specified between two states
∀ o ∈ configOrder ⨝ raisedEvent | (o[cur as cId] ⨝ instanceInState)[stId->from] ⨯ (o[nxt as cId] ⨝ instanceInState)[stId->to] ⨯ o[event] ⊆ allowedTransitions

// Specific: In the initial config machines can not have state vectors attached (since they are uninitialized)
no initialConfig ⨝ PingPongStateVector
  
// Partly generic: Transition function
∀ o ∈ configOrder |  
  // Specific per machine, all possible events:
  ∀ inst ∈ (Instance ⨝ _PingPong)[iId] |  
    let old = (o[cur->cId] ⨝ PingPongStateVector ⨝ instanceInState ⨝ inst)[cId -> oldCId, stId->oldStId, id->oldId, times->oldTimes, iId->oldIId],
        new = (o[nxt->cId] ⨝ PingPongStateVector ⨝ instanceInState ⨝ inst)[cId -> newCId, stId->newStId, id->newId, times->newTimes, iId->iId] | 
    // Iff this is the instance that raised the event then one of the transitions must have happened 
    (some new[iId] ∩ ((raisedEvent ⨝ o)[iId]) ⇔ (       
      // PingPong.start(id)
      (
        // Set the new id coming from the parameters 
        some (new ⨯ (o ⨝ ParamsEventPingPongStart)) where (id > 0 && newId = id) ∧ 
        some (new where newTimes = 0) ∧
        (o ⨝ raisedEvent)[event] = PingPongEventStart ∧ 
        new[newStId] = ((o[cur->cId] ⨝ instanceInState ⨝ inst)[stId as from] ⨝ (allowedTransitions ⨝ PingPongEventStart))[to->newStId] ∧ 
        (changedInstance ⨝ o)[iId] = new[iId] 
      ) 
      ∨ 
      // PingPong.hit()
      ( 
        (o ⨝ raisedEvent)[event] = PingPongEventHit ∧ 
        some (new ⨯ old) where (newTimes = oldTimes + 1) ∧ 
        some (new ⨯ old) where (newId = oldId) ∧ 
        new[newStId] = (old[oldStId as from] ⨝ (allowedTransitions ⨝ PingPongEventHit))[to->newStId] ∧ 
        (changedInstance ⨝ o)[iId] = new[iId] 
      ) 
    )) 
    ∧ 
    // If it is not a transitioning instance, frame the values
    (no new[iId] ∩ (changedInstance ⨝ o)[iId] ⇔ (
      // The instance keeps its current state
      (o[nxt->cId] ⨝ instanceInState ⨝ inst)[stId] = (o[cur->cId] ⨝ instanceInState ⨝ inst)[stId] 
      ∧ (
          // Either there was no values attached yet 
          (no (o[nxt->cId] ⨝ PingPongStateVector ⨝ inst)) 
          ∨ 
          // Or keep the current values
          (some (new ⨯ old) where (newTimes = oldTimes && newId = oldId))
        )
    )) 
    
//(((o[cur->cId] ⨯ inst) ⨝ instanceInState)[stId] ⊆ initialized)

// Specific per machine: Force unique id's
∀ p ∈ PingPongStateVector, pp ∈ PingPongStateVector ∖ p | 
  ((p ∪ pp) ⨝ instanceInState)[stId] ⊆ initialized ⇔ (p[id] = pp[id] ⇒ p[iId] = pp[iId]) 
  
// Goal config, all PingPong instances have hit 3 times 
∃ c ∈ Config | (∃ p ∈ c ⨝ PingPongStateVector | some p where times = 3) ∧ some (PingPongStateVector ⨝ c)[count() as cnt] where cnt = 2
//some (PingPongStateVector)[count() as cnt] where cnt = 4

//∃ c ∈ Config | ∀ p ∈ (Instance ⨝ PingPong)[iId] | some ((c ⨯ p)  ⨝ instanceInState)[stId] ∩ finalized

objectives: minimize Config[count()], minimize PingPongStateVector[count()], minimize ParamsEventPingPongStart[count()]
     