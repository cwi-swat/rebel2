module paper::sepact::checks::OriginatorBankChecks_CanSettleInstruction

spec ClearingAndSettlement
  
  event accept(req: CustomerCreditTransferRequest)
    pre: req.requestedExecutionDate.year = Date[NOW].year, 
         req.requestedExecutionDate.month = Date[NOW].month, 
         req.requestedExecutionDate.day = Date[NOW].day;
    
  states:
    active->active: accept;

spec CustomerCreditTransferRequest  originatorIBAN: IBAN, amount: Money, requestedExecutionDate: Date, beneficiaryIBAN: IBAN,
  beneficiaryBIC: String,
  
  purpose: String,
  purposeCategory: String;   


spec Date[NOW*]
  year: Integer,
  month: Integer,
  day: Integer;
  
  event same(other:Date) 
    pre: this.year = other.year, this.month = other.month, this.day = other.day;
  
  event after(other:Date) 
    pre: this.year > other.year || 
        (this.year = other.year && this.month > other.month) ||
        (this.year = other.year && this.month = other.month && this.day > other.day);
  
    fact CorrectDate
    = always forall d:Date | (
        d.year >= 1900 && d.year <= 2200 &&
        d.month > 0 && d.month < 13 &&
        d.day > 0 && 
        if d.month = 1 then d.day < 32 else
        if d.month = 2 then d.day < 30 else
        if d.month = 3 then d.day < 32 else
        if d.month = 4 then d.day < 31 else
        if d.month = 5 then d.day < 32 else
        if d.month = 6 then d.day < 31 else
        if d.month = 7 then d.day < 32 else
        if d.month = 8 then d.day < 32 else
        if d.month = 9 then d.day < 31 else
        if d.month = 10 then d.day < 32 else
        if d.month = 11 then d.day < 31 else
        d.day < 32); 
  
  fact TimeAlwaysMovesForward
    = always-last (Date[NOW].year' > Date[NOW].year ||
                  (Date[NOW].year' = Date[NOW].year && Date[NOW].month' > Date[NOW].month) ||
                  (Date[NOW].year' = Date[NOW].year && Date[NOW].month' = Date[NOW].month && Date[NOW].day' = Date[NOW].day)); 
  
  states:
    created->created: after,same;
  

spec Money
  cents: Integer,
  currency: Currency;
  
  fact FiniteMoney = always forall m:Money | m.cents >= -99999999999 && m.cents <= 99999999999;
  fact Immutable = always-last forall m:Money | m.cents = m.cents' && m.currency = m.currency';

spec Country[DE,EN,IT,NO,FR,PL,RO,SR,BG,SL,NL,RU,HU,LT,TR,CA,SV,ZH,EL,ES,SQ,PT,CS,FI,SK,DA,HR,LV,ET,JA,KA,MN]


spec Currency[EUR,USD]

spec IBAN
  


spec OriginatorBank 
  instructions: CustomerCreditTransferRequest, cas: ClearingAndSettlement;
  
  event accept(req: CustomerCreditTransferRequest)
    pre: req.originatorIBAN != req.beneficiaryIBAN,
          // can't wire negative money
          req.amount.cents > 0,
          // can only wire payments in EURO
          req.amount.currency = Currency[EUR],
          // execution date must be today or somewhere in the future 
          req.requestedExecutionDate.year >= Date[NOW].year, req.requestedExecutionDate.month >= Date[NOW].month, req.requestedExecutionDate.day >= Date[NOW].day;
    post: // add request to the instruction set
          //this.instructions' = this.instructions + req;
          this.instructions' = req;
           
         
  event settle() 
    pre: this.cas.accept(this.instructions);
             
  states:
    active->active: accept, settle;

assert CanSettleInstruction = eventually exists ob:OriginatorBank | settle on ob;

config Small = ib1,ib2 : IBAN   ,
               m: Money,
               d: Date,
               cas:ClearingAndSettlement,
               ob : OriginatorBank  ,
               ct : CustomerCreditTransferRequest  ;

run CanSettleInstruction from Small in max 2 steps expect trace;