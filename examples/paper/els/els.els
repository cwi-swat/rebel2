module AdaptiveExteriorLight

/** 
 * Configuration parameters: EU market code (sec. 3).
 */

abstract sig State {}
abstract sig Signal {}
abstract sig BooleanSignal extends Signal {}
var sig SignalOn in BooleanSignal {}

/** 
 * System environment, user interface (sec. 4.1).
 */


// the pitmanArm signal
one sig PitmanArmUpDown extends Signal {
  var state : one PitmanArmUpDownState }
abstract sig PitmanArmUpDownState extends State {}
one sig Upward7, Downward7, UpDownNeutral extends PitmanArmUpDownState {}
abstract sig Upward5,Downward5 extends PitmanArmUpDownState {}
// distinguish whether within the 0.5 seconds for tip-blinking
one sig Downward5P, Downward5T extends Downward5 {}
one sig Upward5P, Upward5T extends Upward5 {}

fact Env {
  // when the steering wheel goes back to neutral, release the pitman arm (4.1).
  always {
    (PitmanArmUpDown.state in Downward7+Upward7 and SteeringAngle.state in Left+Right and SteeringAngle.state' in Middle) implies 
      PitmanArmUpDown.state' in UpDownNeutral } }

// the hazardWarningSwitchOn signal
one sig HazardWarningSwitchOn extends BooleanSignal {}

// the keyState signal
one sig KeyState extends Signal {
  var state : one KeyStateState }
abstract sig KeyStateState extends State {}
one sig NoKeyInserted, KeyInserted, KeyInIgnitionOnPosition extends KeyStateState {}

/** 
 * System environment, actuators (sec. 4.3).
 *
 * Most of these sensors report numerical values. These have been abstracted to the ranges identified
 * as relevant to the functional requirements.
 *
 * blinkLeft, blinkRight, lowBeamLeft, lowBeamRight, tailLampLeft, tailLampRight, highBeamMotor 
 * and highBeamRange values abstracted to relevant ranges.
 *
 * Some temporary states (e.g., temporary automatic low beams, ambient lights, moving high beam 
 * range) are explicit to allow delays and timed events. For simplification not all such states are encoded 
 * (e.g., fade out of cornering lights, energy saving of hazard lights).
 *
 * The blinking state of brake light is marked by a distinct state rather than explicitly encoded.
 */

abstract sig Light extends Signal {
  var state : one LightState }
// the low beams and tail lights may be turned on with 100% (On), 50% (Half) or 10% (Low) intensity
abstract sig LightState extends State {}
abstract sig Full,Off extends LightState {}
one sig Half,Low extends LightState {}
// for ambient lights (ELS-19) and automatic low beams (ELS-18), the temporary state is embodied in the state
// for blinkers, tip-blinking cycles are identified 
one sig On, Cycle3, Cycle2, Cycle1, Temp extends Full {}
one sig OffC, Dark4, Dark3, Dark2, Dark1, OffP extends Off {}

// the blinkRight and blinkLeft signals
abstract sig Blink extends Light {} {
  state in Half+On+Cycle3+Cycle2+Cycle1+Off
}
one sig BlinkLeft, BlinkRight extends Blink {}

/** 
 * System modeling, functional requirements (sec. 4.4).
 */

// direction blinking function, ELS-1 - ELS-5, ELS-7, ELS-10
// ELS-6 handled in low beam function
pred directionBlinking {
  // direction blinking pre-condition (p.7)
  KeyState.state not in KeyInIgnitionOnPosition implies Blink.state' in OffP else {
    directionBlinkingDir[BlinkLeft,Downward7,Downward5P,Downward5T]
    directionBlinkingDir[BlinkRight,Upward7,Upward5P,Upward5T]
  }
}

// direction blinking for concrete direction; a1 is the full movement of the arm, a2 the halfway movement and a3 halfway within the 0.5s
pred directionBlinkingDir [l:Blink,a1:PitmanArmUpDownState,a2:PitmanArmUpDownState,a3:PitmanArmUpDownState] {
  l.state' in (
    // started in the middle of hazard lights cycle, allow for dark cycle, ELS-11
    (Blink.state in Full and one Blink.state) implies Blink.state.(iden+Full->OffC) else
    // if moved in other direction, turn off ELS-3, ELS-5 (hazard lights handled elsewhere); if on still move to the dark cycle, ELS-11, which may be propagated
    (PitmanArmUpDown.state in PitmanArmUpDownState-(a1+a2+a3+UpDownNeutral)) implies (Blink.state not in Off implies l.state.(univ->OffC++OffP->OffP) else l.state.(OffC->OffC+univ->OffP)) else
    // if moved halfway start tip-blinking, ELS-2, ELS-5; also interrupts current tip-blinking cycle, ELS-7
    (PitmanArmUpDown.state in a3 and not PitmanArmUpDown.state' in a3) implies (Blink.state not in Off implies Dark4 else Cycle3+Dark4) else
    // to detect continuous tip-blinking, ELS-4
    // gurantees that cycles always end before next one, ELS-11
    PitmanArmUpDown.state in a2  implies (let nxt = iden+Off->Cycle1+Full->Dark1 | l.state.nxt) else
    // if moved down it's turned on with full power, ELS-1, ELS-5; also interrupts tip-blinking cycles, ELS-7
    (PitmanArmUpDown.state in a1 and Blink.state in Off && (Blink-l).state' in OffC) implies l.state else
    (PitmanArmUpDown.state in a1 and Blink.state in Off) implies l.state.(Off->On+OffC->OffC) else
    // if kept halfway down, keep tip-blinking, ELS-4, ELS-5 (On+Off -> Cycle3 when recovering from hazard lights or key off)
    // if other blinker on, force end of dark cycle
    ((Blink-l).state' not in Off and l.state in Dark1+OffC) implies OffP else
    // otherwise, if on tip-blinking advance the cycle, ELS-4, else turn off (or just propagate state)
    let nxt = iden + Dark4->Cycle3 + Dark3->Cycle2 + Dark2->Cycle1 + (Dark1+OffC)->OffP + On->OffC + Cycle3->Dark3 + Cycle2->Dark2 + Cycle1->Dark1 | l.state.nxt
  )
}

// hazard warning light function, ELS-8 - ELS-9, ELS-12 - ELS-13
// ELS-12 and ELS-13 actually implied by direction blinking function
// NOTE: ELS-10 deal with durations, abstracted in the model
pred hazardWarningLight {
  // this guarantees that even a cycle from direction blinking terminates, ELS-11
  some Blink.state & (Full+Half) implies (Blink <: state' in Blink <: state or Blink <: state' = Blink <: state . ((Full+Half)->OffC + Off -> OffP)) else { 
    (Blink.state != OffP and Blink <: state = Blink <: state') or {
      // blinking ratio, ELS-8, ELS-9
      KeyState.state in NoKeyInserted implies Blink.state' = Half else // simplification: should allows delays ELS-9
      Blink.state' in On
    }
  }
}

fact Fairness {
  always {
    PitmanArmUpDown.state in Downward5P implies (PitmanArmUpDown.state in Downward5P since PitmanArmUpDown.state in Downward5T)
    PitmanArmUpDown.state in Upward5P implies (PitmanArmUpDown.state in Upward5P since PitmanArmUpDown.state in Upward5T)
    
    eventually (BlinkLeft.state != BlinkLeft.state' or BlinkLeft.state = OffP)
    eventually (BlinkRight.state != BlinkRight.state' or BlinkRight.state = OffP)
    eventually (BlinkLeft.state != BlinkLeft.state' or BlinkLeft.state = OffP)

    always ((PitmanArmUpDown.state not in Downward7 and SteeringAngle.state not in Left) or CurrentSpeed.state not in Slow) implies eventually CorneringLightLeft not in SignalOn
    always ((PitmanArmUpDown.state not in Upward7 and SteeringAngle.state not in Right) or CurrentSpeed.state not in Slow) implies eventually CorneringLightRight not in SignalOn
  }
}

// a default state for the actuators for the initial state
pred defActuators {
  Blink.state in OffP
}

// system modeling based on functional requirements (4.4)
// state machine feeling, prime state updated based on current state (occasionally previous one)
fact {
  defActuators
  always {
    // the hazard lights have priority (ELS-3)
    HazardWarningSwitchOn not in SignalOn implies directionBlinking
    // the hazard lights are on (ELS-8)
    HazardWarningSwitchOn in SignalOn implies hazardWarningLight
  }
}