module tlaplus::Sequence

spec Boolean[TRUE,FALSE]

spec Elem
  val: Integer,
  nxt: ?Elem,
  head: Boolean;

  assume Immutable = always-last forall e:Elem | e.val = e.val' && e.nxt = e.nxt' && e.head = e.head';

spec Sequence
  elems: set Elem,
  size: Integer;
  
  assume OneHeadAndLastElement = always forall s:Sequence | |{e:s.elems | e.nxt = none}| = 1 && |{e:s.elems | e.head = Boolean[TRUE]}| = 1;
  assume AllReachableFromHead  = always forall s:Sequence | exists h: s.elems | h.head = Boolean[TRUE] && forall e: s.elems |e in h.*nxt;
  assume NoLoops               = always forall s:Sequence | forall e: s.elems | e notin e.^nxt;
  assume Size                  = always forall s:Sequence | s.size = |s.elems|;
  
  states:
    created->created: empty;
  
config OneSeqOfOne   = s: Sequence with elems = {e1}, e1: Elem;
config OneSeqOfThree = s: Sequence with elems = {e1,e2,e3}, e1,e2,e3: Elem;   
config OneSeqOfFive  = s: Sequence with elems = {e1,e2,e3,e4,e5}, e1,e2,e3,e4,e5: Elem;   

assert CanInitialize = eventually exists s:Sequence | |s.elems| > 0;
run CanInitialize from OneSeqOfFive in exact 3 steps expect trace;
 
assert OnlyOneHead = eventually exists s:Sequence | |{e: s.elems | e.head = Boolean[TRUE]}| != 1;
run OnlyOneHead from OneSeqOfFive in max 0 steps expect no trace;

assert HeadCanBeTail = always forall s:Sequence | 
  if (|s.elems| = 1) 
    then (exists e:s.elems | e.nxt = none && e.head = Boolean[TRUE]) 
    else (exists e:s.elems | e.nxt = none && e.head = Boolean[FALSE]);
run HeadCanBeTail from OneSeqOfOne in max 0 steps expect trace;
check HeadCanBeTail from OneSeqOfThree in max 0 steps expect no trace;
check HeadCanBeTail from OneSeqOfFive in max 0 steps expect no trace; 
